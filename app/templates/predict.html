{% extends "base.html" %}

{% block title %}Match Prediction - Cricket Predictor{% endblock %}


{% block content %}
<style>
    /* Segmented Control Styles */
    .segmented-control {
        display: flex;
        background: var(--bg-tertiary);
        border-radius: 8px;
        padding: 4px;
        gap: 4px;
        margin-bottom: 0.75rem;
    }
    
    .segmented-control button {
        flex: 1;
        padding: 0.5rem 1rem;
        border: none;
        background: transparent;
        color: var(--text-secondary);
        font-size: 0.875rem;
        font-weight: 500;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .segmented-control button:hover {
        color: var(--text-primary);
        background: rgba(255, 255, 255, 0.05);
    }
    
    .segmented-control button.active {
        background: var(--accent-primary);
        color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .segmented-control.secondary button.active {
        background: var(--accent-secondary);
    }
    
    .team-filter-label {
        font-size: 0.75rem;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 0.25rem;
        display: block;
    }
    
    /* Timezone Selector (in navbar) */
    .timezone-selector {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .timezone-selector label {
        font-size: 0.75rem;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .timezone-selector select {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 0.35rem 0.5rem;
        font-size: 0.85rem;
        cursor: pointer;
    }
    
    .timezone-selector select:focus {
        outline: none;
        border-color: var(--accent-primary);
    }
    
    /* Role-based Team Selection Styles */
    .team-source-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: var(--accent-primary);
        color: white;
        border-radius: 6px;
        font-size: 0.875rem;
        font-weight: 600;
        margin: 0.5rem 0 1rem 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .role-section {
        margin: 1rem 0;
    }
    
    .role-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: var(--text-primary);
        font-size: 0.95rem;
    }
    
    .constraint {
        color: var(--text-muted);
        font-size: 0.8rem;
        font-weight: 400;
    }
    
    .role-section select {
        width: 100%;
        background: var(--bg-secondary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 0.5rem;
        font-size: 0.9rem;
    }
    
    .role-section select:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px rgba(var(--accent-primary-rgb), 0.1);
    }
    
    .validation-summary {
        margin-top: 1rem;
        padding: 1rem;
        background: var(--bg-secondary);
        border-radius: 6px;
        border-left: 4px solid var(--border-color);
    }
    
    .validation-summary.valid {
        border-left-color: #10b981;
        background: rgba(16, 185, 129, 0.1);
    }
    
    .validation-summary.invalid {
        border-left-color: #ef4444;
        background: rgba(239, 68, 68, 0.1);
    }
    
    .validation-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin: 0.4rem 0;
        font-size: 0.875rem;
    }
    
    .validation-item .icon {
        font-weight: 700;
        font-size: 1rem;
    }
    
    .validation-item.valid {
        color: #10b981;
    }
    
    .validation-item.invalid {
        color: #ef4444;
    }
    
    .validation-item.warning {
        color: #f59e0b;
    }
    
    .team-actions {
        margin-top: 1rem;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    
    .btn-secondary {
        padding: 0.5rem 1rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        color: var(--text-primary);
        font-size: 0.875rem;
        transition: all 0.2s ease;
    }
    
    .btn-secondary:hover {
        background: var(--accent-primary);
        color: white;
        border-color: var(--accent-primary);
    }
    
    /* ========================================
       Two-Panel Player Selection Styles
       ======================================== */
    
    .team-panels-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin-top: 1rem;
    }
    
    .player-panel {
        background: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        overflow: hidden;
    }
    
    .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1rem;
        background: var(--bg-tertiary);
        border-bottom: 1px solid var(--border-color);
        font-weight: 600;
        font-size: 0.9rem;
    }
    
    .panel-header .count {
        background: var(--accent-primary);
        color: white;
        padding: 0.2rem 0.6rem;
        border-radius: 12px;
        font-size: 0.75rem;
    }
    
    .panel-header.selected .count {
        background: #10b981;
    }
    
    .panel-header.selected.incomplete .count {
        background: #f59e0b;
    }
    
    .player-list {
        max-height: 400px;
        overflow-y: auto;
        padding: 0.5rem;
    }
    
    .player-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.6rem 0.75rem;
        margin: 0.25rem 0;
        background: var(--bg-primary);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.15s ease;
        border: 1px solid transparent;
    }
    
    .player-item:hover {
        background: var(--bg-tertiary);
        border-color: var(--accent-primary);
    }
    
    .player-item.in-xi {
        opacity: 0.5;
        pointer-events: none;
    }
    
    .player-item .order-num {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--accent-primary);
        color: white;
        border-radius: 50%;
        font-size: 0.75rem;
        font-weight: 600;
        flex-shrink: 0;
    }
    
    .player-item .add-icon {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--bg-tertiary);
        color: var(--text-muted);
        border-radius: 50%;
        font-size: 1rem;
        flex-shrink: 0;
    }
    
    .player-item:hover .add-icon {
        background: var(--accent-primary);
        color: white;
    }
    
    .player-info {
        flex: 1;
        min-width: 0;
    }
    
    .player-name {
        font-weight: 500;
        font-size: 0.9rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .player-stat {
        font-size: 0.75rem;
        color: var(--text-muted);
    }
    
    .role-badge {
        display: inline-block;
        padding: 0.15rem 0.5rem;
        border-radius: 4px;
        font-size: 0.7rem;
        font-weight: 600;
        text-transform: uppercase;
        flex-shrink: 0;
    }
    
    .role-badge.wk {
        background: #8b5cf6;
        color: white;
    }
    
    .role-badge.bat {
        background: #3b82f6;
        color: white;
    }
    
    .role-badge.ar {
        background: #10b981;
        color: white;
    }
    
    .role-badge.bowl {
        background: #ef4444;
        color: white;
    }
    
    /* Warning Banner */
    .squad-warning {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        background: rgba(245, 158, 11, 0.15);
        border: 1px solid #f59e0b;
        border-radius: 6px;
        margin-bottom: 1rem;
        color: #f59e0b;
        font-size: 0.875rem;
    }
    
    .squad-warning .icon {
        font-size: 1.25rem;
    }
    
    /* Suggestions Section */
    .suggestions-section {
        margin-top: 0.5rem;
        padding: 0.75rem;
        background: var(--bg-tertiary);
        border-radius: 6px;
        border: 1px dashed var(--border-color);
    }
    
    .suggestions-header {
        font-size: 0.8rem;
        color: var(--text-muted);
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .suggestion-item {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.75rem;
        margin: 0.25rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        font-size: 0.8rem;
        cursor: pointer;
        transition: all 0.15s ease;
    }
    
    .suggestion-item:hover {
        background: var(--accent-primary);
        color: white;
        border-color: var(--accent-primary);
    }
    
    /* Toss Highlight */
    .toss-highlight {
        background: rgba(245, 158, 11, 0.2) !important;
        border-color: #f59e0b !important;
        animation: toss-pulse 2s ease-in-out infinite;
    }
    
    @keyframes toss-pulse {
        0%, 100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.4); }
        50% { box-shadow: 0 0 0 4px rgba(245, 158, 11, 0); }
    }
    
    /* Manual Mode Collapse */
    .manual-mode-section {
        border: 1px solid var(--border-color);
        border-radius: 8px;
        margin-bottom: 1rem;
        overflow: hidden;
    }
    
    .manual-mode-section.collapsed .manual-mode-content {
        display: none;
    }
    
    .manual-mode-toggle {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1rem;
        background: var(--bg-tertiary);
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--text-secondary);
    }
    
    .manual-mode-toggle:hover {
        color: var(--text-primary);
    }
    
    .manual-mode-content {
        padding: 1rem;
    }
    
    /* Panel Actions */
    .panel-actions {
        display: flex;
        gap: 0.5rem;
        padding: 0.75rem;
        border-top: 1px solid var(--border-color);
        background: var(--bg-tertiary);
    }
    
    .panel-actions button {
        flex: 1;
        padding: 0.5rem;
        font-size: 0.8rem;
    }
</style>

<div class="hero" style="padding: 2rem;">
    <h1>Match Prediction</h1>
    <p>Select an upcoming match or manually configure teams to simulate</p>
</div>

<!-- Upcoming Matches (Next 24 Hours) -->
<div id="upcoming-matches" class="card" style="margin-bottom: 1.5rem; border: 2px solid var(--accent-primary);">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h2 class="card-title" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
            <span style="font-size: 1.5rem;">üèè</span> Upcoming Matches
        </h2>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button class="btn" onclick="loadUpcomingMatches(true)" style="padding: 0.5rem 1rem;">
                üîÑ Refresh
            </button>
        </div>
    </div>
    
    <!-- Data Source Toggle -->
    <div style="margin-bottom: 1rem;">
        <span class="team-filter-label">Data Source</span>
        <div class="segmented-control" id="data-source-control">
            <button class="active" data-value="crex" onclick="setDataSource('crex')">CREX (Recommended)</button>
            <button data-value="espn" onclick="setDataSource('espn')">ESPN Cricinfo</button>
            <button data-value="api" onclick="setDataSource('api')">Cricket Data API</button>
        </div>
        <small id="source-info" style="color: var(--text-muted); display: block; margin-top: 0.25rem;">
            CREX provides comprehensive T20 coverage with squads, venue stats, and live toss data
        </small>
    </div>
    
    <div id="matches-loading" style="text-align: center; padding: 2rem;">
        <div class="spinner" style="margin: 0 auto;"></div>
        <p style="color: var(--text-secondary); margin-top: 0.5rem;">Loading upcoming matches...</p>
    </div>
    
    <div id="matches-list" style="display: none;">
        <!-- Matches will be populated here by JavaScript -->
    </div>
    
    <div id="matches-empty" style="display: none; text-align: center; padding: 2rem; color: var(--text-secondary);">
        <p>No matches scheduled in the next 24 hours.</p>
        <p style="font-size: 0.875rem; margin-top: 0.5rem;">You can still manually select teams below.</p>
    </div>
    
    <div id="t20-match-info" style="display: none; margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <strong id="t20-match-name"></strong>
            <span id="t20-match-date" style="color: var(--text-muted);"></span>
        </div>
        <div style="font-size: 0.875rem; color: var(--text-secondary);">
            <span id="t20-team1-info"></span> vs <span id="t20-team2-info"></span>
        </div>
    </div>
</div>

<!-- Hidden elements for match loading -->
<div id="t20-loading" style="display: none; text-align: center; padding: 1rem;">
    <div class="spinner" style="margin: 0 auto;"></div>
    <p style="color: var(--text-secondary); margin-top: 0.5rem;">Loading match data...</p>
</div>

<div class="grid grid-2">
    <!-- Team 1 Selection -->
    <div class="card">
        <h2 class="card-title" style="color: var(--accent-primary);">
            <span id="team1-title">Team 1</span>
        </h2>
        
        <!-- Team Source Badge -->
        <div class="team-source-badge" id="team1-source-badge" style="display: none;">
            <span id="team1-source-icon">üîÑ</span>
            <span id="team1-source-text">Loading...</span>
        </div>
        
        <!-- Warning Banner for Incomplete Squad -->
        <div class="squad-warning" id="team1-warning" style="display: none;">
            <span class="icon">‚ö†Ô∏è</span>
            <span id="team1-warning-text">Only 9 players matched. Add more from suggestions below.</span>
        </div>
        
        <!-- Manual Mode Section (collapsed by default when match selected) -->
        <div class="manual-mode-section collapsed" id="team1-manual-section">
            <div class="manual-mode-toggle" onclick="toggleManualMode(1)">
                <span>üìù Manual Team Selection</span>
                <span id="team1-manual-arrow">‚ñº</span>
            </div>
            <div class="manual-mode-content">
                <!-- Gender Filter -->
                <span class="team-filter-label">Gender</span>
                <div class="segmented-control" id="team1-gender-control">
                    <button class="active" data-value="male" onclick="setTeamFilter(1, 'gender', 'male')">Men's</button>
                    <button data-value="female" onclick="setTeamFilter(1, 'gender', 'female')">Women's</button>
                </div>
                
                <!-- Type Filter -->
                <span class="team-filter-label">Team Type</span>
                <div class="segmented-control secondary" id="team1-type-control">
                    <button class="active" data-value="all" onclick="setTeamFilter(1, 'type', 'all')">All</button>
                    <button data-value="international" onclick="setTeamFilter(1, 'type', 'international')">International</button>
                    <button data-value="club" onclick="setTeamFilter(1, 'type', 'club')">Club / Domestic</button>
                </div>
                
                <div class="form-group">
                    <label>Select Team <span id="team1-count" style="color: var(--text-muted); font-weight: normal;"></span></label>
                    <select id="team1-select" onchange="onManualTeamSelect(1)">
                        <option value="">-- Select Team --</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Two-Panel Player Selection -->
        <div class="team-panels-container" id="team1-panels">
            <!-- Available Squad Panel -->
            <div class="player-panel">
                <div class="panel-header">
                    <span>Available Squad</span>
                    <span class="count" id="team1-available-count">0</span>
                </div>
                <div class="player-list" id="team1-available-list">
                    <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                        Select a match or team to load players
                    </div>
                </div>
            </div>
            
            <!-- Selected XI Panel -->
            <div class="player-panel">
                <div class="panel-header selected" id="team1-selected-header">
                    <span>Selected XI</span>
                    <span class="count" id="team1-selected-count">0/11</span>
                </div>
                <div class="player-list" id="team1-selected-list">
                    <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                        Click players from Available Squad to add
                    </div>
                </div>
                <div class="panel-actions">
                    <button onclick="autoOrderXI(1)" class="btn-secondary">‚ÜïÔ∏è Re-order</button>
                    <button onclick="clearTeam(1)" class="btn-secondary">üóë Clear</button>
                </div>
            </div>
        </div>
        
        <!-- Suggestions Section -->
        <div class="suggestions-section" id="team1-suggestions" style="display: none;">
            <div class="suggestions-header">
                <span>üí°</span>
                <span>Suggested from Database</span>
            </div>
            <div id="team1-suggestions-list">
                <!-- Populated dynamically -->
            </div>
        </div>
        
        <!-- Validation Summary -->
        <div id="team1-validation" class="validation-summary" style="display: none;">
        </div>
    </div>
    
    <!-- Team 2 Selection -->
    <div class="card">
        <h2 class="card-title" style="color: var(--accent-secondary);">
            <span id="team2-title">Team 2</span>
        </h2>
        
        <!-- Team Source Badge -->
        <div class="team-source-badge" id="team2-source-badge" style="display: none;">
            <span id="team2-source-icon">üîÑ</span>
            <span id="team2-source-text">Loading...</span>
        </div>
        
        <!-- Warning Banner for Incomplete Squad -->
        <div class="squad-warning" id="team2-warning" style="display: none;">
            <span class="icon">‚ö†Ô∏è</span>
            <span id="team2-warning-text">Only 9 players matched. Add more from suggestions below.</span>
        </div>
        
        <!-- Manual Mode Section (collapsed by default when match selected) -->
        <div class="manual-mode-section collapsed" id="team2-manual-section">
            <div class="manual-mode-toggle" onclick="toggleManualMode(2)">
                <span>üìù Manual Team Selection</span>
                <span id="team2-manual-arrow">‚ñº</span>
            </div>
            <div class="manual-mode-content">
                <!-- Gender Filter -->
                <span class="team-filter-label">Gender</span>
                <div class="segmented-control secondary" id="team2-gender-control">
                    <button class="active" data-value="male" onclick="setTeamFilter(2, 'gender', 'male')">Men's</button>
                    <button data-value="female" onclick="setTeamFilter(2, 'gender', 'female')">Women's</button>
                </div>
                
                <!-- Type Filter -->
                <span class="team-filter-label">Team Type</span>
                <div class="segmented-control secondary" id="team2-type-control">
                    <button class="active" data-value="all" onclick="setTeamFilter(2, 'type', 'all')">All</button>
                    <button data-value="international" onclick="setTeamFilter(2, 'type', 'international')">International</button>
                    <button data-value="club" onclick="setTeamFilter(2, 'type', 'club')">Club / Domestic</button>
                </div>
                
                <div class="form-group">
                    <label>Select Team <span id="team2-count" style="color: var(--text-muted); font-weight: normal;"></span></label>
                    <select id="team2-select" onchange="onManualTeamSelect(2)">
                        <option value="">-- Select Team --</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Two-Panel Player Selection -->
        <div class="team-panels-container" id="team2-panels">
            <!-- Available Squad Panel -->
            <div class="player-panel">
                <div class="panel-header">
                    <span>Available Squad</span>
                    <span class="count" id="team2-available-count">0</span>
                </div>
                <div class="player-list" id="team2-available-list">
                    <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                        Select a match or team to load players
                    </div>
                </div>
            </div>
            
            <!-- Selected XI Panel -->
            <div class="player-panel">
                <div class="panel-header selected" id="team2-selected-header">
                    <span>Selected XI</span>
                    <span class="count" id="team2-selected-count">0/11</span>
                </div>
                <div class="player-list" id="team2-selected-list">
                    <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                        Click players from Available Squad to add
                    </div>
                </div>
                <div class="panel-actions">
                    <button onclick="autoOrderXI(2)" class="btn-secondary">‚ÜïÔ∏è Re-order</button>
                    <button onclick="clearTeam(2)" class="btn-secondary">üóë Clear</button>
                </div>
            </div>
        </div>
        
        <!-- Suggestions Section -->
        <div class="suggestions-section" id="team2-suggestions" style="display: none;">
            <div class="suggestions-header">
                <span>üí°</span>
                <span>Suggested from Database</span>
            </div>
            <div id="team2-suggestions-list">
                <!-- Populated dynamically -->
            </div>
        </div>
        
        <!-- Validation Summary -->
        <div id="team2-validation" class="validation-summary" style="display: none;">
        </div>
    </div>
</div>

<!-- Venue Selection -->
<div class="card">
    <h2 class="card-title">Match Conditions</h2>
    <div class="grid grid-2">
        <div class="form-group">
            <label>Venue (affects scoring patterns)</label>
            <select id="venue-select">
                <option value="">-- Neutral Venue --</option>
            </select>
            <small style="color: var(--text-muted);" id="venue-info"></small>
        </div>
        <div class="form-group">
            <label style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="use-toss" style="width: auto;">
                Simulate Toss
            </label>
            <small style="color: var(--text-muted);">Uses historical bat/field preferences (T20: 55% elect to field)</small>
        </div>
    </div>
</div>

<!-- Simulation Options -->
<div class="card">
    <h2 class="card-title">Simulation Options</h2>
    <div class="grid grid-3">
        <div class="form-group">
            <label>Simulator Engine</label>
            <select id="simulator-type">
                <option value="fast">Fast Lookup (0.1ms/match)</option>
                <option value="nn" selected>Neural Network (5ms/match) + Scorecard</option>
            </select>
        </div>
        <div class="form-group">
            <label>Number of Simulations</label>
            <input type="number" id="n-simulations" value="1000" min="100" max="10000" step="100">
        </div>
        <div class="form-group">
            <label>&nbsp;</label>
            <button class="btn btn-primary" onclick="runSimulation()" style="width: 100%;">
                Run Simulation
            </button>
        </div>
    </div>
</div>

<!-- Results -->
<div id="results" class="card" style="display: none;">
    <h2 class="card-title">Prediction Results</h2>
    
    <div class="grid grid-2" style="margin-bottom: 2rem;">
        <!-- Team 1 Result -->
        <div style="text-align: center; padding: 2rem; background: var(--bg-tertiary); border-radius: 12px;">
            <div style="font-size: 1.25rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                <span id="result-team1-name">Team 1</span>
            </div>
            <div class="stat-value" style="color: var(--accent-primary);" id="result-team1-prob">--%</div>
            <div class="probability-bar">
                <div class="probability-fill" id="result-team1-bar" style="background: var(--accent-primary); width: 0%;"></div>
            </div>
            <div style="margin-top: 1rem; color: var(--text-secondary);">
                Avg Score: <span id="result-team1-score">--</span>
            </div>
            <div style="color: var(--text-muted); font-size: 0.875rem;">
                Range: <span id="result-team1-range">-- - --</span>
            </div>
        </div>
        
        <!-- Team 2 Result -->
        <div style="text-align: center; padding: 2rem; background: var(--bg-tertiary); border-radius: 12px;">
            <div style="font-size: 1.25rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                <span id="result-team2-name">Team 2</span>
            </div>
            <div class="stat-value" style="color: var(--accent-secondary);" id="result-team2-prob">--%</div>
            <div class="probability-bar">
                <div class="probability-fill" id="result-team2-bar" style="background: var(--accent-secondary); width: 0%;"></div>
            </div>
            <div style="margin-top: 1rem; color: var(--text-secondary);">
                Avg Score: <span id="result-team2-score">--</span>
            </div>
            <div style="color: var(--text-muted); font-size: 0.875rem;">
                Range: <span id="result-team2-range">-- - --</span>
            </div>
        </div>
    </div>
    
    <div id="toss-result" style="text-align: center; margin-bottom: 1rem; display: none;">
        <div style="background: var(--bg-secondary); padding: 0.75rem 1rem; border-radius: 8px; display: inline-block;">
            üé≤ <span id="toss-stats-text">Toss simulated per match</span>
        </div>
    </div>
    
    <div style="text-align: center; color: var(--text-muted); font-size: 0.875rem;">
        <span id="result-meta"></span>
    </div>
</div>

<!-- Scorecard Section (NN simulator only) - ESPN Cricinfo Style -->
<div id="scorecard-section" class="card" style="display: none; margin-top: 1.5rem;">
    <h2 class="card-title">Sample Scorecard</h2>
    <p style="color: var(--text-secondary); margin-bottom: 1rem; font-size: 0.875rem;">
        Representative match outcome based on simulation
    </p>
    
    <!-- Match Result Banner -->
    <div id="scorecard-result" style="text-align: center; padding: 1rem; margin-bottom: 1.5rem; background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); border-radius: 8px; color: white;">
        <span style="font-size: 1.25rem; font-weight: 600;" id="scorecard-result-text"></span>
    </div>
    
    <!-- Innings Tabs -->
    <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
        <button class="btn btn-primary" id="tab-inn1" onclick="showInnings(1)">1st Innings</button>
        <button class="btn" id="tab-inn2" onclick="showInnings(2)">2nd Innings</button>
    </div>
    
    <!-- First Innings Scorecard (ESPN Style) -->
    <div id="innings1-card">
        <!-- Team Header -->
        <div style="background: var(--accent-primary); color: white; padding: 0.75rem 1rem; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center;">
            <span style="font-weight: 700; font-size: 1.1rem;" id="innings1-team-name">Team 1</span>
            <span style="font-weight: 700; font-size: 1.1rem;" id="innings1-total">0/0 (0 Ov)</span>
        </div>
        
        <!-- Batting Table -->
        <table class="espn-scorecard" style="width: 100%; border-collapse: collapse; margin-bottom: 0.5rem;">
            <thead>
                <tr style="background: var(--bg-tertiary); font-size: 0.75rem; text-transform: uppercase; color: var(--text-muted);">
                    <th style="text-align: left; padding: 0.5rem; width: 40%;">Batter</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">R</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">B</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">4s</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">6s</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">SR</th>
                </tr>
            </thead>
            <tbody id="innings1-batting"></tbody>
            <tfoot>
                <tr style="background: var(--bg-tertiary); font-size: 0.85rem;">
                    <td style="padding: 0.5rem; color: var(--text-muted);">Extras</td>
                    <td colspan="5" style="padding: 0.5rem; text-align: left;" id="innings1-extras">(lb 0, w 0, nb 0) 0</td>
                </tr>
                <tr style="background: var(--bg-secondary); font-weight: 700;">
                    <td style="padding: 0.75rem;">TOTAL</td>
                    <td colspan="5" style="padding: 0.75rem; text-align: left;" id="innings1-total-row">0 (0 wkts, 0 Ov)</td>
                </tr>
            </tfoot>
        </table>
        
        <!-- Bowling Header -->
        <div style="background: var(--bg-tertiary); padding: 0.5rem 1rem; margin-top: 1rem; border-radius: 8px 8px 0 0;">
            <span style="font-weight: 600; font-size: 0.9rem; color: var(--text-secondary);">BOWLING</span>
        </div>
        
        <!-- Bowling Table -->
        <table class="espn-scorecard" style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: var(--bg-tertiary); font-size: 0.75rem; text-transform: uppercase; color: var(--text-muted);">
                    <th style="text-align: left; padding: 0.5rem; width: 40%;">Bowler</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">O</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">M</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">R</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">W</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">Econ</th>
                </tr>
            </thead>
            <tbody id="innings1-bowling"></tbody>
        </table>
    </div>
    
    <!-- Second Innings Scorecard (ESPN Style) -->
    <div id="innings2-card" style="display: none;">
        <!-- Team Header -->
        <div style="background: var(--accent-secondary); color: white; padding: 0.75rem 1rem; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center;">
            <span style="font-weight: 700; font-size: 1.1rem;" id="innings2-team-name">Team 2</span>
            <span style="font-weight: 700; font-size: 1.1rem;" id="innings2-total">0/0 (0 Ov)</span>
        </div>
        <div style="background: var(--bg-secondary); padding: 0.5rem 1rem; font-size: 0.85rem; color: var(--text-muted);">
            Target: <span id="innings2-target" style="font-weight: 600; color: var(--text-primary);">-</span>
        </div>
        
        <!-- Batting Table -->
        <table class="espn-scorecard" style="width: 100%; border-collapse: collapse; margin-bottom: 0.5rem;">
            <thead>
                <tr style="background: var(--bg-tertiary); font-size: 0.75rem; text-transform: uppercase; color: var(--text-muted);">
                    <th style="text-align: left; padding: 0.5rem; width: 40%;">Batter</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">R</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">B</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">4s</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">6s</th>
                    <th style="text-align: center; padding: 0.5rem; width: 8%;">SR</th>
                </tr>
            </thead>
            <tbody id="innings2-batting"></tbody>
            <tfoot>
                <tr style="background: var(--bg-tertiary); font-size: 0.85rem;">
                    <td style="padding: 0.5rem; color: var(--text-muted);">Extras</td>
                    <td colspan="5" style="padding: 0.5rem; text-align: left;" id="innings2-extras">(lb 0, w 0, nb 0) 0</td>
                </tr>
                <tr style="background: var(--bg-secondary); font-weight: 700;">
                    <td style="padding: 0.75rem;">TOTAL</td>
                    <td colspan="5" style="padding: 0.75rem; text-align: left;" id="innings2-total-row">0 (0 wkts, 0 Ov)</td>
                </tr>
            </tfoot>
        </table>
        
        <!-- Bowling Header -->
        <div style="background: var(--bg-tertiary); padding: 0.5rem 1rem; margin-top: 1rem; border-radius: 8px 8px 0 0;">
            <span style="font-weight: 600; font-size: 0.9rem; color: var(--text-secondary);">BOWLING</span>
        </div>
        
        <!-- Bowling Table -->
        <table class="espn-scorecard" style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: var(--bg-tertiary); font-size: 0.75rem; text-transform: uppercase; color: var(--text-muted);">
                    <th style="text-align: left; padding: 0.5rem; width: 40%;">Bowler</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">O</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">M</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">R</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">W</th>
                    <th style="text-align: center; padding: 0.5rem; width: 10%;">Econ</th>
                </tr>
            </thead>
            <tbody id="innings2-bowling"></tbody>
        </table>
    </div>
</div>

<!-- Loading with Progress -->
<div id="loading" class="card" style="display: none;">
    <h3 style="text-align: center; margin-bottom: 1rem;">Running Simulation...</h3>
    
    <!-- Progress Bar -->
    <div style="background: var(--bg-tertiary); border-radius: 8px; height: 24px; overflow: hidden; margin-bottom: 1rem;">
        <div id="progress-fill" style="height: 100%; background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary)); width: 0%; transition: width 0.3s ease;"></div>
    </div>
    
    <!-- Progress Stats -->
    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; text-align: center;">
        <div>
            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-primary);" id="progress-count">0</div>
            <div style="color: var(--text-muted); font-size: 0.75rem;">COMPLETED</div>
        </div>
        <div>
            <div style="font-size: 1.5rem; font-weight: 700; color: var(--text-primary);" id="progress-rate">--</div>
            <div style="color: var(--text-muted); font-size: 0.75rem;">SIMS/SEC</div>
        </div>
        <div>
            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-secondary);" id="progress-eta">--</div>
            <div style="color: var(--text-muted); font-size: 0.75rem;">ETA (SEC)</div>
        </div>
    </div>
    
    <p style="text-align: center; color: var(--text-muted); margin-top: 1rem; font-size: 0.875rem;" id="progress-status">
        Initializing...
    </p>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Current gender selection (for API match loading)
    let currentGender = 'male';
    let currentSeriesId = '';
    let currentSeriesName = '';
    
    // Data source: 'crex', 'espn', or 'api'
    let currentDataSource = 'crex';
    
    // Team filter state (for manual selection)
    const teamFilters = {
        1: { gender: 'male', type: 'all' },
        2: { gender: 'male', type: 'all' }
    };
    
    // Player panel state - stores all players and selection state
    const teamPlayerData = {
        1: { available: [], selected: [], teamName: '', teamDbId: null, matchUrl: null },
        2: { available: [], selected: [], teamName: '', teamDbId: null, matchUrl: null }
    };
    
    // ========================================
    // Player Panel Functions
    // ========================================
    
    /**
     * Render the two-panel player selection UI for a team
     * @param {number} teamNum - 1 or 2
     * @param {Array} squad - All squad players (from scraper or DB)
     * @param {Array} selectedXI - Players to put in Selected XI panel (optional, auto-picks if null)
     */
    function renderTeamPanels(teamNum, squad, selectedXI = null) {
        console.log(`[renderTeamPanels] Team ${teamNum}: ${squad.length} squad players, ${selectedXI ? selectedXI.length : 'auto'} selected`);
        
        const availableList = document.getElementById(`team${teamNum}-available-list`);
        const selectedList = document.getElementById(`team${teamNum}-selected-list`);
        
        if (!availableList || !selectedList) {
            console.error(`[renderTeamPanels] Could not find panel elements for team ${teamNum}`);
            return;
        }
        
        // Determine which players go to selected vs available
        let selected = [];
        let available = [];
        
        if (selectedXI && selectedXI.length > 0) {
            // Use provided XI
            const selectedIds = new Set(selectedXI.map(p => p.db_player_id || p.player_id || p.id));
            selected = selectedXI.slice(0, 11);
            available = squad.filter(p => {
                const pid = p.db_player_id || p.player_id || p.id;
                return !selectedIds.has(pid);
            });
        } else {
            // Smart auto-select: prioritize by role (WK first, then balanced team)
            // 1. Get all wicketkeepers first
            const wicketkeepers = squad.filter(p => {
                const role = normalizeRole(p.role || p.player_role);
                return role === 'WK' || p.is_wicketkeeper;
            });
            
            // 2. Get other players by role
            const batters = squad.filter(p => {
                const role = normalizeRole(p.role || p.player_role);
                return role === 'BAT' && !p.is_wicketkeeper;
            });
            const allrounders = squad.filter(p => {
                const role = normalizeRole(p.role || p.player_role);
                return role === 'AR';
            });
            const bowlers = squad.filter(p => {
                const role = normalizeRole(p.role || p.player_role);
                return role === 'BOWL';
            });
            
            // 3. Build optimal XI: 1 WK, batters, all-rounders, bowlers
            selected = [];
            
            // Add at least 1 WK (all if only 1-2)
            const wkCount = Math.min(wicketkeepers.length, Math.max(1, wicketkeepers.length <= 2 ? wicketkeepers.length : 1));
            selected.push(...wicketkeepers.slice(0, wkCount));
            
            // Add batters (aim for 3-4)
            const batCount = Math.min(batters.length, 4);
            selected.push(...batters.slice(0, batCount));
            
            // Add all-rounders (aim for 2-3)
            const arCount = Math.min(allrounders.length, 3);
            selected.push(...allrounders.slice(0, arCount));
            
            // Add bowlers (aim for 3-4)
            const bowlCount = Math.min(bowlers.length, 4);
            selected.push(...bowlers.slice(0, bowlCount));
            
            // Fill remaining slots if needed (up to 11)
            if (selected.length < 11) {
                const selectedIds = new Set(selected.map(p => p.db_player_id || p.player_id || p.crex_id));
                const remaining = squad.filter(p => {
                    const pid = p.db_player_id || p.player_id || p.crex_id;
                    return !selectedIds.has(pid);
                });
                const needed = 11 - selected.length;
                selected.push(...remaining.slice(0, needed));
            }
            
            // Trim to 11 if over
            selected = selected.slice(0, 11);
            
            // Available = everyone not selected
            const selectedIds = new Set(selected.map(p => p.db_player_id || p.player_id || p.crex_id));
            available = squad.filter(p => {
                const pid = p.db_player_id || p.player_id || p.crex_id;
                return !selectedIds.has(pid);
            });
            
            console.log(`[renderTeamPanels] Smart selection breakdown:`);
            console.log(`  WKs (${wicketkeepers.length}):`, wicketkeepers.map(p => `${p.name} [role=${p.role}, is_wk=${p.is_wicketkeeper}]`));
            console.log(`  BATs (${batters.length}):`, batters.map(p => p.name));
            console.log(`  ARs (${allrounders.length}):`, allrounders.map(p => p.name));
            console.log(`  BOWLs (${bowlers.length}):`, bowlers.map(p => p.name));
            console.log(`  Final XI (${selected.length}):`, selected.map(p => `${p.name} [${normalizeRole(p.role)}]`));
            
            // SAFETY CHECK: Ensure at least 1 WK is selected
            const selectedWKs = selected.filter(p => normalizeRole(p.role || p.player_role) === 'WK' || p.is_wicketkeeper);
            if (selectedWKs.length === 0 && wicketkeepers.length > 0) {
                console.warn('[renderTeamPanels] No WK in selected XI! Adding first available WK.');
                // Find a WK not in selected and add them
                const wkToAdd = wicketkeepers[0];
                const wkId = wkToAdd.db_player_id || wkToAdd.player_id || wkToAdd.crex_id;
                
                // Remove last non-WK to make room
                if (selected.length >= 11) {
                    // Find a non-essential player to swap out (prefer removing extra AR)
                    const selectedARs = selected.filter(p => normalizeRole(p.role) === 'AR');
                    if (selectedARs.length > 2) {
                        const toRemove = selectedARs[selectedARs.length - 1];
                        selected = selected.filter(p => p !== toRemove);
                        available.push(toRemove);
                    } else {
                        // Just remove the last player
                        available.push(selected.pop());
                    }
                }
                
                // Add the WK
                selected.unshift(wkToAdd);  // Add WK at the beginning
                available = available.filter(p => {
                    const pid = p.db_player_id || p.player_id || p.crex_id;
                    return pid !== wkId;
                });
                
                console.log(`[renderTeamPanels] Added WK: ${wkToAdd.name}`);
            }
        }
        
        // Store in state
        teamPlayerData[teamNum].available = available;
        teamPlayerData[teamNum].selected = selected;
        
        // Auto-order the selected XI
        autoOrderXI(teamNum);
        
        // Render both panels
        renderAvailablePanel(teamNum);
        renderSelectedPanel(teamNum);
        
        // Update validation and warnings
        updateTeamValidation(teamNum);
    }
    
    /**
     * Render the Available Squad panel
     */
    function renderAvailablePanel(teamNum) {
        const list = document.getElementById(`team${teamNum}-available-list`);
        const countEl = document.getElementById(`team${teamNum}-available-count`);
        const players = teamPlayerData[teamNum].available;
        
        countEl.textContent = players.length;
        
        if (players.length === 0) {
            list.innerHTML = `<div style="padding: 1.5rem; text-align: center; color: var(--text-muted); font-size: 0.9rem;">
                All players in Selected XI
            </div>`;
            return;
        }
        
        list.innerHTML = players.map(p => renderPlayerItem(p, 'available', teamNum)).join('');
    }
    
    /**
     * Render the Selected XI panel
     */
    function renderSelectedPanel(teamNum) {
        const list = document.getElementById(`team${teamNum}-selected-list`);
        const countEl = document.getElementById(`team${teamNum}-selected-count`);
        const headerEl = document.getElementById(`team${teamNum}-selected-header`);
        const players = teamPlayerData[teamNum].selected;
        
        countEl.textContent = `${players.length}/11`;
        
        // Update header class based on completeness
        headerEl.classList.toggle('incomplete', players.length < 11);
        
        if (players.length === 0) {
            list.innerHTML = `<div style="padding: 1.5rem; text-align: center; color: var(--text-muted); font-size: 0.9rem;">
                Click players from Available Squad to add
            </div>`;
            return;
        }
        
        list.innerHTML = players.map((p, idx) => renderPlayerItem(p, 'selected', teamNum, idx + 1)).join('');
    }
    
    /**
     * Render a single player item
     */
    function renderPlayerItem(player, panel, teamNum, orderNum = null) {
        const playerId = player.db_player_id || player.player_id || player.id;
        const name = player.name || player.player_name || 'Unknown';
        const role = normalizeRole(player.role || player.player_role || 'Unknown');
        const roleBadgeClass = getRoleBadgeClass(role);
        
        // Get key stat based on role
        const stat = getPlayerKeyStat(player, role);
        
        if (panel === 'available') {
            return `
                <div class="player-item" onclick="movePlayer(${teamNum}, '${playerId}', 'selected')">
                    <span class="add-icon">+</span>
                    <div class="player-info">
                        <div class="player-name">${name}</div>
                        <div class="player-stat">${stat}</div>
                    </div>
                    <span class="role-badge ${roleBadgeClass}">${role}</span>
                </div>
            `;
        } else {
            return `
                <div class="player-item" onclick="movePlayer(${teamNum}, '${playerId}', 'available')">
                    <span class="order-num">${orderNum}</span>
                    <div class="player-info">
                        <div class="player-name">${name}</div>
                        <div class="player-stat">${stat}</div>
                    </div>
                    <span class="role-badge ${roleBadgeClass}">${role}</span>
                </div>
            `;
        }
    }
    
    /**
     * Normalize role to standard abbreviation
     */
    function normalizeRole(role) {
        if (!role) return 'BAT';
        const r = role.toLowerCase();
        if (r.includes('keep') || r.includes('wk')) return 'WK';
        if (r.includes('all') || r.includes('ar')) return 'AR';
        if (r.includes('bowl')) return 'BOWL';
        return 'BAT';
    }
    
    /**
     * Get CSS class for role badge
     */
    function getRoleBadgeClass(role) {
        switch (role) {
            case 'WK': return 'wk';
            case 'AR': return 'ar';
            case 'BOWL': return 'bowl';
            default: return 'bat';
        }
    }
    
    /**
     * Get key stat string for a player based on role
     */
    function getPlayerKeyStat(player, role) {
        if (role === 'BOWL') {
            const econ = player.economy || player.econ;
            const wickets = player.wickets || player.total_wickets;
            if (econ) return `Econ: ${parseFloat(econ).toFixed(1)}`;
            if (wickets) return `${wickets} wickets`;
            return '';
        } else {
            const sr = player.strike_rate || player.sr || player.batting_sr;
            const avg = player.batting_avg || player.average;
            const runs = player.runs || player.total_runs;
            if (sr) return `SR: ${parseFloat(sr).toFixed(1)}`;
            if (avg) return `Avg: ${parseFloat(avg).toFixed(1)}`;
            if (runs) return `${runs} runs`;
            return '';
        }
    }
    
    /**
     * Move a player between Available and Selected panels
     */
    function movePlayer(teamNum, playerId, toPanel) {
        const data = teamPlayerData[teamNum];
        const fromPanel = toPanel === 'selected' ? 'available' : 'selected';
        
        // Find player in source panel
        const fromList = data[fromPanel];
        const playerIdx = fromList.findIndex(p => 
            (p.db_player_id || p.player_id || p.id) == playerId
        );
        
        if (playerIdx === -1) {
            console.warn(`[movePlayer] Player ${playerId} not found in ${fromPanel}`);
            return;
        }
        
        // Check if moving to selected would exceed 11
        if (toPanel === 'selected' && data.selected.length >= 11) {
            console.log(`[movePlayer] XI already has 11 players`);
            return;
        }
        
        // Move player
        const [player] = fromList.splice(playerIdx, 1);
        data[toPanel].push(player);
        
        // If adding to selected, auto-order
        if (toPanel === 'selected') {
            autoOrderXI(teamNum);
        }
        
        // Re-render panels
        renderAvailablePanel(teamNum);
        renderSelectedPanel(teamNum);
        updateTeamValidation(teamNum);
    }
    
    /**
     * Sort Selected XI by role: WK first, then BAT, AR, BOWL
     */
    function autoOrderXI(teamNum) {
        const data = teamPlayerData[teamNum];
        const roleOrder = { 'WK': 0, 'BAT': 1, 'AR': 2, 'BOWL': 3 };
        
        data.selected.sort((a, b) => {
            const roleA = normalizeRole(a.role || a.player_role);
            const roleB = normalizeRole(b.role || b.player_role);
            const orderA = roleOrder[roleA] ?? 1;
            const orderB = roleOrder[roleB] ?? 1;
            
            if (orderA !== orderB) return orderA - orderB;
            
            // Within same role, sort by batting average/SR for batters, wickets for bowlers
            if (roleA === 'BOWL') {
                return (b.wickets || 0) - (a.wickets || 0);
            } else {
                return (b.batting_avg || b.average || 0) - (a.batting_avg || a.average || 0);
            }
        });
        
        // Re-render if called directly (not from renderTeamPanels)
        if (document.getElementById(`team${teamNum}-selected-list`).innerHTML !== '') {
            renderSelectedPanel(teamNum);
        }
    }
    
    /**
     * Update validation state for a team
     */
    function updateTeamValidation(teamNum) {
        const data = teamPlayerData[teamNum];
        const selectedCount = data.selected.length;
        const validationEl = document.getElementById(`team${teamNum}-validation`);
        const warningEl = document.getElementById(`team${teamNum}-warning`);
        const warningText = document.getElementById(`team${teamNum}-warning-text`);
        
        // Show warning if less than 11 players
        if (selectedCount < 11) {
            warningEl.style.display = 'flex';
            warningText.textContent = `Only ${selectedCount} players selected. Need ${11 - selectedCount} more.`;
        } else {
            warningEl.style.display = 'none';
        }
        
        // Count roles in XI
        const roles = data.selected.reduce((acc, p) => {
            const role = normalizeRole(p.role || p.player_role);
            acc[role] = (acc[role] || 0) + 1;
            return acc;
        }, {});
        
        const hasKeeper = (roles['WK'] || 0) >= 1;
        const hasBowlers = (roles['BOWL'] || 0) >= 4 || ((roles['BOWL'] || 0) + (roles['AR'] || 0)) >= 5;
        const isValid = selectedCount === 11 && hasKeeper;
        
        if (selectedCount > 0) {
            validationEl.style.display = 'block';
            validationEl.className = `validation-summary ${isValid ? 'valid' : 'invalid'}`;
            validationEl.innerHTML = `
                <div class="validation-item ${selectedCount === 11 ? 'valid' : 'invalid'}">
                    <span class="icon">${selectedCount === 11 ? '‚úì' : '‚úó'}</span>
                    <span>${selectedCount}/11 players selected</span>
                </div>
                <div class="validation-item ${hasKeeper ? 'valid' : 'invalid'}">
                    <span class="icon">${hasKeeper ? '‚úì' : '‚úó'}</span>
                    <span>Wicketkeeper: ${roles['WK'] || 0}</span>
                </div>
                <div class="validation-item ${hasBowlers ? 'valid' : 'warning'}">
                    <span class="icon">${hasBowlers ? '‚úì' : '‚ö†'}</span>
                    <span>Bowlers: ${roles['BOWL'] || 0} + ${roles['AR'] || 0} AR = ${(roles['BOWL'] || 0) + (roles['AR'] || 0)} bowling options</span>
                </div>
            `;
        } else {
            validationEl.style.display = 'none';
        }
        
        // Update Run Simulation button state
        updateSimulationButton();
    }
    
    /**
     * Clear all players from a team
     */
    function clearTeam(teamNum) {
        const data = teamPlayerData[teamNum];
        // Move all selected back to available
        data.available = [...data.available, ...data.selected];
        data.selected = [];
        
        renderAvailablePanel(teamNum);
        renderSelectedPanel(teamNum);
        updateTeamValidation(teamNum);
    }
    
    /**
     * Toggle manual mode section visibility
     */
    function toggleManualMode(teamNum) {
        const section = document.getElementById(`team${teamNum}-manual-section`);
        const arrow = document.getElementById(`team${teamNum}-manual-arrow`);
        
        section.classList.toggle('collapsed');
        arrow.textContent = section.classList.contains('collapsed') ? '‚ñº' : '‚ñ≤';
    }
    
    /**
     * Update the Run Simulation button based on team validity
     */
    function updateSimulationButton() {
        const team1Valid = teamPlayerData[1].selected.length === 11;
        const team2Valid = teamPlayerData[2].selected.length === 11;
        
        const btn = document.querySelector('button[onclick="runSimulation()"]');
        if (btn) {
            btn.disabled = !(team1Valid && team2Valid);
            btn.style.opacity = (team1Valid && team2Valid) ? '1' : '0.5';
        }
    }
    
    /**
     * Load player suggestions from database for incomplete squads
     */
    async function loadSuggestions(teamNum, teamDbId) {
        const suggestionsSection = document.getElementById(`team${teamNum}-suggestions`);
        const suggestionsList = document.getElementById(`team${teamNum}-suggestions-list`);
        
        if (!teamDbId) {
            suggestionsSection.style.display = 'none';
            return;
        }
        
        try {
            const gender = teamFilters[teamNum].gender;
            const response = await fetch(`/api/team/${teamDbId}/recent-lineup?gender=${gender}`);
            const data = await response.json();
            
            if (data.success && data.players) {
                // Filter out players already in squad
                const currentPlayerIds = new Set([
                    ...teamPlayerData[teamNum].available.map(p => p.db_player_id || p.player_id || p.id),
                    ...teamPlayerData[teamNum].selected.map(p => p.db_player_id || p.player_id || p.id)
                ]);
                
                const suggestions = data.players
                    .filter(p => !currentPlayerIds.has(p.player_id))
                    .slice(0, 10);  // Limit to 10 suggestions
                
                if (suggestions.length > 0) {
                    suggestionsSection.style.display = 'block';
                    suggestionsList.innerHTML = suggestions.map(p => `
                        <span class="suggestion-item" onclick="addSuggestion(${teamNum}, ${JSON.stringify(p).replace(/"/g, '&quot;')})">
                            <span>+</span>
                            <span>${p.name}</span>
                            <span class="role-badge ${getRoleBadgeClass(normalizeRole(p.role))}">${normalizeRole(p.role)}</span>
                        </span>
                    `).join('');
                } else {
                    suggestionsSection.style.display = 'none';
                }
            }
        } catch (error) {
            console.error('Error loading suggestions:', error);
            suggestionsSection.style.display = 'none';
        }
    }
    
    /**
     * Add a suggested player to the available squad
     */
    function addSuggestion(teamNum, player) {
        // Convert player format to match squad format
        const squadPlayer = {
            db_player_id: player.player_id,
            player_id: player.player_id,
            name: player.name,
            role: player.role,
            player_role: player.role,
            batting_avg: player.stats?.runs ? (player.stats.runs / Math.max(1, player.stats.matches)) : 0,
            wickets: player.stats?.wickets || 0
        };
        
        // Add to available
        teamPlayerData[teamNum].available.push(squadPlayer);
        
        // Re-render
        renderAvailablePanel(teamNum);
        
        // Remove from suggestions
        const suggestionsList = document.getElementById(`team${teamNum}-suggestions-list`);
        const items = suggestionsList.querySelectorAll('.suggestion-item');
        items.forEach(item => {
            if (item.textContent.includes(player.name)) {
                item.remove();
            }
        });
        
        // Hide suggestions section if empty
        if (suggestionsList.children.length === 0) {
            document.getElementById(`team${teamNum}-suggestions`).style.display = 'none';
        }
    }
    
    /**
     * Handle manual team selection from dropdown
     */
    async function onManualTeamSelect(teamNum) {
        const teamSelect = document.getElementById(`team${teamNum}-select`);
        const teamId = teamSelect.value;
        
        if (!teamId) {
            // Clear panels
            teamPlayerData[teamNum].available = [];
            teamPlayerData[teamNum].selected = [];
            renderAvailablePanel(teamNum);
            renderSelectedPanel(teamNum);
            return;
        }
        
        const teamName = teamSelect.options[teamSelect.selectedIndex].text;
        
        // Update team title
        document.getElementById(`team${teamNum}-title`).textContent = teamName;
        
        // Store team data
        teamPlayerData[teamNum].teamName = teamName;
        teamPlayerData[teamNum].teamDbId = parseInt(teamId);
        teamPlayerData[teamNum].matchUrl = null;
        
        // Show source badge
        const badge = document.getElementById(`team${teamNum}-source-badge`);
        document.getElementById(`team${teamNum}-source-icon`).textContent = 'üìã';
        document.getElementById(`team${teamNum}-source-text`).textContent = 'Manual Selection';
        badge.style.display = 'inline-flex';
        
        // Load players from database
        try {
            const gender = teamFilters[teamNum].gender;
            const response = await fetch(`/api/team/${teamId}/recent-lineup?gender=${gender}`);
            const data = await response.json();
            
            if (data.success && data.players) {
                // Convert to squad format
                const squad = data.players.map(p => ({
                    db_player_id: p.player_id,
                    player_id: p.player_id,
                    name: p.name,
                    role: p.role,
                    player_role: p.role,
                    batting_avg: p.stats?.runs ? (p.stats.runs / Math.max(1, p.stats.matches)) : 0,
                    wickets: p.stats?.wickets || 0,
                    strike_rate: 0  // Will be fetched if needed
                }));
                
                renderTeamPanels(teamNum, squad, null);
            }
        } catch (error) {
            console.error('Error loading team players:', error);
        }
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
        // Set timezone dropdown to saved value
        const tzSelect = document.getElementById('timezone-select');
        if (tzSelect) {
            tzSelect.value = currentTimezone;
        }
        
        loadTeamsForTeam(1);
        loadTeamsForTeam(2);
        loadVenues();
        loadUpcomingMatches();  // Load upcoming matches
    });
    
    // Listen for timezone changes from global selector
    window.addEventListener('timezoneChanged', (event) => {
        // Reload matches to update displayed times
        loadUpcomingMatches();
    });
    
    // Format a GMT ISO datetime string in the selected timezone
    function formatTimeInTimezone(gmtIsoString) {
        if (!gmtIsoString) return null;
        
        try {
            const dt = new Date(gmtIsoString.endsWith('Z') ? gmtIsoString : gmtIsoString + 'Z');
            if (isNaN(dt.getTime())) return null;
            
            return dt.toLocaleString('en-AU', {
                timeZone: currentTimezone,
                weekday: 'short',
                day: 'numeric',
                month: 'short',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true
            });
        } catch (e) {
            console.error('Error formatting time:', e);
            return null;
        }
    }
    
    // Get short timezone abbreviation
    function getTimezoneAbbr() {
        try {
            const dt = new Date();
            const parts = dt.toLocaleString('en-AU', {
                timeZone: currentTimezone,
                timeZoneName: 'short'
            }).split(' ');
            return parts[parts.length - 1];
        } catch (e) {
            return '';
        }
    }
    
    // Calculate countdown from GMT time
    function calculateCountdown(gmtIsoString) {
        if (!gmtIsoString) return null;
        
        try {
            const dt = new Date(gmtIsoString.endsWith('Z') ? gmtIsoString : gmtIsoString + 'Z');
            if (isNaN(dt.getTime())) return null;
            
            const now = Date.now();
            const diff = dt.getTime() - now;
            const absDiff = Math.abs(diff);
            const hours = Math.floor(absDiff / (1000 * 60 * 60));
            const mins = Math.floor((absDiff % (1000 * 60 * 60)) / (1000 * 60));
            
            let color = '#4caf50'; // Green
            let text = '';
            
            if (diff < 0) {
                // Match started (negative)
                color = '#f44336'; // Red
                text = '-' + hours + 'h ' + mins + 'm';
            } else if (diff < 60 * 60 * 1000) {
                // Within 1 hour
                color = '#ff9800'; // Orange
                text = hours + 'h ' + mins + 'm';
            } else {
                text = hours + 'h ' + mins + 'm';
            }
            
            return { text, color, timestamp: dt.getTime() };
        } catch (e) {
            return null;
        }
    }
    
    // Set data source and reload matches
    function setDataSource(source) {
        currentDataSource = source;
        
        // Update button states
        const control = document.getElementById('data-source-control');
        control.querySelectorAll('button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.value === source);
        });
        
        // Update info text
        const info = document.getElementById('source-info');
        if (source === 'crex') {
            info.textContent = 'CREX provides comprehensive T20 coverage with squads, venue stats, and live toss data';
        } else if (source === 'espn') {
            info.textContent = 'ESPN Cricinfo provides comprehensive coverage of all T20 matches worldwide';
        } else {
            info.textContent = 'Cricket Data API - requires API key, covers major tournaments only';
        }
        
        // Reload matches
        loadUpcomingMatches();
    }
    
    // Set team filter and reload teams
    function setTeamFilter(teamNum, filterType, value) {
        teamFilters[teamNum][filterType] = value;
        
        // Update button states
        const controlId = `team${teamNum}-${filterType === 'gender' ? 'gender' : 'type'}-control`;
        const control = document.getElementById(controlId);
        control.querySelectorAll('button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.value === value);
        });
        
        // Reload teams for this team
        loadTeamsForTeam(teamNum);
    }
    
    // Load teams for a specific team panel
    async function loadTeamsForTeam(teamNum) {
        const { gender, type } = teamFilters[teamNum];
        
        try {
            const response = await fetch(`/api/teams?gender=${gender}&team_type=${type}`);
            const data = await response.json();
            
            if (data.success) {
                const select = document.getElementById(`team${teamNum}-select`);
                const countSpan = document.getElementById(`team${teamNum}-count`);
                const currentValue = select.value;
                
                select.innerHTML = '<option value="">-- Select Team --</option>';
                data.teams.forEach(team => {
                    const opt = document.createElement('option');
                    opt.value = team.team_id;
                    opt.textContent = team.name;
                    select.appendChild(opt);
                });
                
                // Try to restore selection, or clear if not in new list
                if (currentValue) {
                    select.value = currentValue;
                    if (select.value !== currentValue) {
                        // Team not in filtered list, clear players
                        clearPlayersForTeam(teamNum);
                    }
                }
                
                // Update count display
                countSpan.textContent = `(${data.count} teams)`;
            }
        } catch (error) {
            console.error(`Error loading teams for team ${teamNum}:`, error);
        }
    }
    
    // Clear player selections for a team
    function clearPlayersForTeam(teamNum) {
        document.getElementById(`team${teamNum}-batters`).innerHTML = '';
        document.getElementById(`team${teamNum}-bowlers`).innerHTML = '';
    }
    
    // Upcoming Matches Functions
    async function loadUpcomingMatches(forceRefresh = false) {
        const loadingEl = document.getElementById('matches-loading');
        const listEl = document.getElementById('matches-list');
        const emptyEl = document.getElementById('matches-empty');
        
        loadingEl.style.display = 'block';
        listEl.style.display = 'none';
        emptyEl.style.display = 'none';
        
        try {
            // Choose endpoint based on data source
            let endpoint = currentDataSource === 'crex'
                ? '/api/crex/upcoming'
                : currentDataSource === 'espn' 
                    ? '/api/espn/upcoming?hours_ahead=72'
                    : '/api/t20/upcoming';
            
            console.log(`[loadUpcomingMatches] Fetching from: ${endpoint}`);
            const response = await fetch(endpoint);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            console.log(`[loadUpcomingMatches] Response success: ${data.success}, series count: ${data.matches_by_series?.length || 0}`);
            
            loadingEl.style.display = 'none';
            
            if (data.success && data.matches_by_series && data.matches_by_series.length > 0) {
                listEl.innerHTML = '';
                
                data.matches_by_series.forEach(series => {
                    const genderBadge = series.gender === 'female' ? 
                        '<span style="background: #e91e63; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-left: 0.5rem;">W</span>' :
                        '<span style="background: #2196f3; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-left: 0.5rem;">M</span>';
                    
                    const seriesHtml = `
                        <div style="margin-bottom: 1.5rem;">
                            <h3 style="font-size: 1rem; color: var(--accent-primary); margin-bottom: 0.5rem; display: flex; align-items: center;">
                                ${series.series_name} ${genderBadge}
                            </h3>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                ${series.matches.map(m => {
                                    // Use timezone-aware formatting
                                    let displayDateTime = '';
                                    let countdownHtml = '';
                                    let matchTimestamp = 0;
                                    
                                    if (m.date_time_gmt) {
                                        // Format in selected timezone
                                        const formatted = formatTimeInTimezone(m.date_time_gmt);
                                        if (formatted) {
                                            displayDateTime = formatted;
                                        }
                                        
                                        // Calculate countdown
                                        const countdown = calculateCountdown(m.date_time_gmt);
                                        if (countdown) {
                                            matchTimestamp = countdown.timestamp;
                                            countdownHtml = '<span class="countdown-timer" data-timestamp="' + matchTimestamp + '" style="font-weight: 600; color: ' + countdown.color + '; font-size: 0.85rem; min-width: 70px; text-align: right;">' + countdown.text + '</span>';
                                        }
                                    }
                                    
                                    // Fallback if no parsed datetime
                                    if (!displayDateTime) {
                                        displayDateTime = m.start_time ? m.start_time : (m.status || 'TBD');
                                    }
                                    
                                    // Handle CREX, ESPN and API data formats
                                    let matchTitle;
                                    if (m.team1 && m.team2) {
                                        matchTitle = m.team1 + ' vs ' + m.team2;
                                    } else {
                                        matchTitle = m.title || 'TBD vs TBD';
                                    }
                                    const matchType = m.match_type || '';
                                    // Use venue_city from schedule, fallback to venue
                                    const matchVenue = m.venue_city || m.venue || '';
                                    const matchId = m.match_id || m.crex_id || m.espn_id || '';
                                    const matchUrl = m.match_url || '';
                                    const hasSquad = m.has_squad || m.has_squads || false;
                                    const isCrex = currentDataSource === 'crex';
                                    const isEspn = currentDataSource === 'espn';
                                    const isExternalSource = isCrex || isEspn;
                                    
                                    // Source label for display
                                    let sourceLabel = '';
                                    if (isCrex) {
                                        sourceLabel = '<span style="color: #4caf50; margin-left: 0.5rem;">CREX</span>';
                                    } else if (isEspn) {
                                        sourceLabel = '<span style="color: #ff9800; margin-left: 0.5rem;">ESPNcricinfo</span>';
                                    }
                                    
                                    // Status indicators (data fetched fresh on selection)
                                    let statusIcons = '';
                                    
                                    return `
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid ${series.gender === 'female' ? '#e91e63' : '#2196f3'};" data-match-url="${matchUrl}">
                                        <div style="flex: 1;">
                                            <div style="font-weight: 500;">${matchTitle}${matchType ? ' <span style="font-weight: 400; color: var(--text-muted); font-size: 0.85rem;">(' + matchType + ')</span>' : ''}</div>
                                            <div style="font-size: 0.8rem; color: var(--text-muted);">
                                                <span style="color: var(--text-secondary);">${displayDateTime}</span>${matchVenue ? ' ‚Ä¢ ' + matchVenue : ''}
                                                <span class="prefetch-status" style="margin-left: 0.5rem;">${statusIcons}</span>
                                                ${sourceLabel}
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                                            ${countdownHtml}
                                            <button class="btn btn-primary" style="padding: 0.4rem 1rem; font-size: 0.85rem;" 
                                                    onclick="selectMatch('${isExternalSource ? matchUrl : matchId}', '${series.gender}', ${isExternalSource})">
                                                Select
                                            </button>
                                        </div>
                                    </div>
                                `}).join('')}
                            </div>
                        </div>
                    `;
                    listEl.innerHTML += seriesHtml;
                });
                
                listEl.style.display = 'block';
                console.log(`Loaded ${data.total_matches} upcoming matches`);
                
                // Start the countdown timer updater
                startCountdownUpdater();
                
                // Status display updated (no prefetch needed)
                updatePrefetchStatusDisplay();
            } else {
                emptyEl.style.display = 'block';
            }
        } catch (error) {
            console.error('Error loading upcoming matches:', error);
            loadingEl.style.display = 'none';
            emptyEl.innerHTML = '<p style="color: var(--danger);">Error loading matches. Please try again.</p>';
            emptyEl.style.display = 'block';
        }
    }
    
    // Update match cards with status indicators (no prefetch needed - data fetched fresh)
    function updateMatchCardsWithPrefetchStatus() {
        // No-op - status indicators removed since we fetch fresh on selection
    }
    
    // Update status display after loading matches (no prefetch needed)
    function updatePrefetchStatusDisplay() {
        // No-op - prefetch removed
    }
    
    // Countdown timer updater
    let countdownInterval = null;
    
    function startCountdownUpdater() {
        // Clear any existing interval
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }
        
        // Update immediately
        updateCountdowns();
        
        // Then update every 30 seconds
        countdownInterval = setInterval(updateCountdowns, 30000);
    }
    
    function updateCountdowns() {
        const timers = document.querySelectorAll('.countdown-timer');
        const now = Date.now();
        
        timers.forEach(timer => {
            const timestamp = parseInt(timer.dataset.timestamp);
            if (!timestamp) return;
            
            const diff = timestamp - now;
            const absDiff = Math.abs(diff);
            const hours = Math.floor(absDiff / (1000 * 60 * 60));
            const mins = Math.floor((absDiff % (1000 * 60 * 60)) / (1000 * 60));
            
            let color = '#4caf50'; // Green
            let text = '';
            
            if (diff < 0) {
                // Match has started (negative countdown)
                color = '#f44336'; // Red
                text = '-' + hours + 'h ' + mins + 'm';
            } else if (diff < 60 * 60 * 1000) {
                // Within 1 hour
                color = '#ff9800'; // Orange
                text = hours + 'h ' + mins + 'm';
            } else {
                // More than 1 hour away
                text = hours + 'h ' + mins + 'm';
            }
            
            timer.style.color = color;
            timer.textContent = text;
        });
    }
    
    async function selectMatch(matchIdOrUrl, gender, isExternalSource = false) {
        // Set the gender for correct model selection
        currentGender = gender;
        
        // Sync segmented controls to match gender AND set type to "all" for API matches
        // (API matches can be international or franchise, so we need all teams)
        [1, 2].forEach(teamNum => {
            teamFilters[teamNum].gender = gender;
            teamFilters[teamNum].type = 'all';  // Show all teams for API matches
            
            // Update gender control
            const genderControl = document.getElementById(`team${teamNum}-gender-control`);
            genderControl.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === gender);
            });
            
            // Update type control - select "all"
            const typeControl = document.getElementById(`team${teamNum}-type-control`);
            typeControl.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === 'all');
            });
        });
        
        console.log(`[DEBUG] selectMatch - Loading teams for gender: ${gender}, type: all`);
        
        // Load teams (all types) and venues for this gender
        await loadTeams();
        console.log(`[DEBUG] selectMatch - Teams loaded successfully`);
        
        // Small delay to ensure dropdown DOM is fully updated
        await new Promise(resolve => setTimeout(resolve, 150));
        console.log(`[DEBUG] selectMatch - Dropdown population delay complete`);
        
        await loadVenues();
        console.log(`[DEBUG] selectMatch - Venues loaded successfully`);
        
        // Load the match - use CREX, ESPN or API endpoint based on source
        if (currentDataSource === 'crex' && isExternalSource) {
            await loadCrexMatch(matchIdOrUrl);
        } else if (currentDataSource === 'espn' && isExternalSource) {
            await loadEspnMatch(matchIdOrUrl);
        } else {
            await loadT20MatchById(matchIdOrUrl);
        }
    }
    
    async function loadCrexMatch(matchUrl) {
        if (!matchUrl) {
            alert('Invalid match URL');
            return;
        }
        
        // Show loading
        document.getElementById('t20-loading').style.display = 'block';
        document.getElementById('t20-match-info').style.display = 'none';
        
        try {
            const response = await fetch(`/api/crex/match?url=${encodeURIComponent(matchUrl)}`);
            const data = await response.json();
            
            document.getElementById('t20-loading').style.display = 'none';
            
            if (data.success && data.match) {
                const match = data.match;
                
                // Get team names
                const team1Name = match.team1?.name || match.team1_db?.name || 'Team 1';
                const team2Name = match.team2?.name || match.team2_db?.name || 'Team 2';
                
                // Update match info display
                document.getElementById('t20-match-name').textContent = `${team1Name} vs ${team2Name}`;
                document.getElementById('t20-match-date').textContent = `${match.start_date || ''} ${match.start_time || ''}`;
                
                const team1Players = match.team1?.players?.length || 0;
                const team2Players = match.team2?.players?.length || 0;
                const team1Matched = match.team1?.players?.filter(p => p.db_player_id)?.length || 0;
                const team2Matched = match.team2?.players?.filter(p => p.db_player_id)?.length || 0;
                
                document.getElementById('t20-team1-info').textContent = `${team1Matched}/${team1Players} matched`;
                document.getElementById('t20-team2-info').textContent = `${team2Matched}/${team2Players} matched`;
                document.getElementById('t20-match-info').style.display = 'block';
                
                console.log(`CREX match loaded: ${team1Name} vs ${team2Name}`);
                console.log(`  Series: ${match.series_name}`);
                console.log(`  Venue: ${match.venue?.name} -> DB: ${match.venue?.db_venue_name}`);
                console.log(`  Team 1 Squad: ${team1Players} players (${team1Matched} matched)`);
                console.log(`  Team 2 Squad: ${team2Players} players (${team2Matched} matched)`);
                
                // Store match URL for later use
                window.currentMatchUrl = matchUrl;
                
                // Store squad data globally
                window.espnSquadData = {
                    team1: match.team1?.players || [],
                    team2: match.team2?.players || []
                };
                
                // ========================================
                // AUTO-POPULATE TEAM 1 using new panel system
                // ========================================
                const team1Squad = (match.team1?.players || []).filter(p => p.db_player_id);
                if (team1Squad.length > 0) {
                    // Update team title
                    document.getElementById('team1-title').textContent = team1Name;
                    
                    // Store team data
                    teamPlayerData[1].teamName = team1Name;
                    teamPlayerData[1].teamDbId = match.team1_db?.team_id || null;
                    teamPlayerData[1].matchUrl = matchUrl;
                    
                    // Collapse manual mode section
                    document.getElementById('team1-manual-section').classList.add('collapsed');
                    document.getElementById('team1-manual-arrow').textContent = '‚ñº';
                    
                    // Show source badge
                    const badge = document.getElementById('team1-source-badge');
                    document.getElementById('team1-source-icon').textContent = 'üèè';
                    document.getElementById('team1-source-text').textContent = `CREX: ${team1Squad.length} players`;
                    badge.style.display = 'inline-flex';
                    
                    // Determine playing XI vs bench (if available from live match)
                    let playingXI = null;
                    if (match.team1?.playing_xi && match.team1.playing_xi.length > 0) {
                        playingXI = match.team1.playing_xi;
                        console.log(`  Team 1 Playing XI: ${playingXI.length} players`);
                    }
                    
                    // Render the panels
                    renderTeamPanels(1, team1Squad, playingXI);
                    
                    // Check if we need suggestions (less than 11 matched)
                    if (team1Squad.length < 11 && match.team1_db?.team_id) {
                        loadSuggestions(1, match.team1_db.team_id);
                    }
                }
                
                // ========================================
                // AUTO-POPULATE TEAM 2 using new panel system
                // ========================================
                const team2Squad = (match.team2?.players || []).filter(p => p.db_player_id);
                if (team2Squad.length > 0) {
                    // Update team title
                    document.getElementById('team2-title').textContent = team2Name;
                    
                    // Store team data
                    teamPlayerData[2].teamName = team2Name;
                    teamPlayerData[2].teamDbId = match.team2_db?.team_id || null;
                    teamPlayerData[2].matchUrl = matchUrl;
                    
                    // Collapse manual mode section
                    document.getElementById('team2-manual-section').classList.add('collapsed');
                    document.getElementById('team2-manual-arrow').textContent = '‚ñº';
                    
                    // Show source badge
                    const badge = document.getElementById('team2-source-badge');
                    document.getElementById('team2-source-icon').textContent = 'üèè';
                    document.getElementById('team2-source-text').textContent = `CREX: ${team2Squad.length} players`;
                    badge.style.display = 'inline-flex';
                    
                    // Determine playing XI vs bench (if available from live match)
                    let playingXI = null;
                    if (match.team2?.playing_xi && match.team2.playing_xi.length > 0) {
                        playingXI = match.team2.playing_xi;
                        console.log(`  Team 2 Playing XI: ${playingXI.length} players`);
                    }
                    
                    // Render the panels
                    renderTeamPanels(2, team2Squad, playingXI);
                    
                    // Check if we need suggestions (less than 11 matched)
                    if (team2Squad.length < 11 && match.team2_db?.team_id) {
                        loadSuggestions(2, match.team2_db.team_id);
                    }
                }
                
                // ========================================
                // AUTO-SELECT VENUE
                // ========================================
                if (match.venue?.db_venue_id) {
                    const venueSelect = document.getElementById('venue-select');
                    venueSelect.value = match.venue.db_venue_id;
                    console.log(`Auto-selected venue: ${match.venue.db_venue_name} (ID: ${match.venue.db_venue_id})`);
                }
                
                // ========================================
                // HANDLE TOSS (highlight if available)
                // ========================================
                const useTossCheckbox = document.getElementById('use-toss');
                if (match.toss_winner && match.toss_decision) {
                    console.log(`  Toss: ${match.toss_winner} elected to ${match.toss_decision}`);
                    // Pre-set toss and highlight
                    useTossCheckbox.checked = false;  // Don't simulate - we know the result
                    useTossCheckbox.parentElement.classList.add('toss-highlight');
                    
                    // Store toss info for simulation
                    window.tossResult = {
                        winner: match.toss_winner,
                        decision: match.toss_decision
                    };
                } else {
                    useTossCheckbox.checked = true;
                    useTossCheckbox.parentElement.classList.remove('toss-highlight');
                    window.tossResult = null;
                }
                
            } else {
                alert('Error loading CREX match: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            document.getElementById('t20-loading').style.display = 'none';
            console.error('Error loading CREX match:', error);
            alert('Error loading match data from CREX');
        }
    }
    
    async function loadEspnMatch(matchUrl) {
        if (!matchUrl) {
            alert('Invalid match URL');
            return;
        }
        
        // Show loading
        document.getElementById('t20-loading').style.display = 'block';
        document.getElementById('t20-match-info').style.display = 'none';
        
        try {
            const response = await fetch(`/api/espn/match?url=${encodeURIComponent(matchUrl)}`);
            const data = await response.json();
            
            document.getElementById('t20-loading').style.display = 'none';
            
            if (data.success && data.match) {
                const match = data.match;
                
                // Get team names
                const team1Name = match.team1?.long_name || match.team1_db?.name || 'Team 1';
                const team2Name = match.team2?.long_name || match.team2_db?.name || 'Team 2';
                
                // Update match info display
                document.getElementById('t20-match-name').textContent = `${team1Name} vs ${team2Name}`;
                document.getElementById('t20-match-date').textContent = `${match.start_date} ${match.start_time || ''}`;
                
                const team1Players = match.team1?.players?.length || 0;
                const team2Players = match.team2?.players?.length || 0;
                const team1Matched = match.team1?.players?.filter(p => p.db_player_id)?.length || 0;
                const team2Matched = match.team2?.players?.filter(p => p.db_player_id)?.length || 0;
                
                document.getElementById('t20-team1-info').textContent = `${team1Matched}/${team1Players} matched`;
                document.getElementById('t20-team2-info').textContent = `${team2Matched}/${team2Players} matched`;
                document.getElementById('t20-match-info').style.display = 'block';
                
                console.log(`ESPN match loaded: ${team1Name} vs ${team2Name}`);
                console.log(`  Venue: ${match.venue?.name} -> DB: ${match.venue?.db_venue_name}`);
                console.log(`  Team 1 Squad: ${team1Players} players (${team1Matched} matched)`);
                console.log(`  Team 2 Squad: ${team2Players} players (${team2Matched} matched)`);
                
                // Store match URL for later use
                window.currentMatchUrl = matchUrl;
                
                // Store squad data globally
                window.espnSquadData = {
                    team1: match.team1?.players || [],
                    team2: match.team2?.players || []
                };
                
                // ========================================
                // AUTO-POPULATE TEAM 1 using new panel system
                // ========================================
                const team1Squad = (match.team1?.players || []).filter(p => p.db_player_id);
                if (team1Squad.length > 0) {
                    // Update team title
                    document.getElementById('team1-title').textContent = team1Name;
                    
                    // Store team data
                    teamPlayerData[1].teamName = team1Name;
                    teamPlayerData[1].teamDbId = match.team1_db?.team_id || null;
                    teamPlayerData[1].matchUrl = matchUrl;
                    
                    // Collapse manual mode section
                    document.getElementById('team1-manual-section').classList.add('collapsed');
                    document.getElementById('team1-manual-arrow').textContent = '‚ñº';
                    
                    // Show source badge
                    const badge = document.getElementById('team1-source-badge');
                    document.getElementById('team1-source-icon').textContent = 'üìä';
                    document.getElementById('team1-source-text').textContent = `ESPN: ${team1Squad.length} players`;
                    badge.style.display = 'inline-flex';
                    
                    // Render the panels
                    renderTeamPanels(1, team1Squad, null);
                    
                    // Check if we need suggestions (less than 11 matched)
                    if (team1Squad.length < 11 && match.team1_db?.team_id) {
                        loadSuggestions(1, match.team1_db.team_id);
                    }
                }
                
                // ========================================
                // AUTO-POPULATE TEAM 2 using new panel system
                // ========================================
                const team2Squad = (match.team2?.players || []).filter(p => p.db_player_id);
                if (team2Squad.length > 0) {
                    // Update team title
                    document.getElementById('team2-title').textContent = team2Name;
                    
                    // Store team data
                    teamPlayerData[2].teamName = team2Name;
                    teamPlayerData[2].teamDbId = match.team2_db?.team_id || null;
                    teamPlayerData[2].matchUrl = matchUrl;
                    
                    // Collapse manual mode section
                    document.getElementById('team2-manual-section').classList.add('collapsed');
                    document.getElementById('team2-manual-arrow').textContent = '‚ñº';
                    
                    // Show source badge
                    const badge = document.getElementById('team2-source-badge');
                    document.getElementById('team2-source-icon').textContent = 'üìä';
                    document.getElementById('team2-source-text').textContent = `ESPN: ${team2Squad.length} players`;
                    badge.style.display = 'inline-flex';
                    
                    // Render the panels
                    renderTeamPanels(2, team2Squad, null);
                    
                    // Check if we need suggestions (less than 11 matched)
                    if (team2Squad.length < 11 && match.team2_db?.team_id) {
                        loadSuggestions(2, match.team2_db.team_id);
                    }
                }
                
                // ========================================
                // AUTO-SELECT VENUE
                // ========================================
                if (match.venue?.db_venue_id) {
                    const venueSelect = document.getElementById('venue-select');
                    venueSelect.value = match.venue.db_venue_id;
                    console.log(`Auto-selected venue: ${match.venue.db_venue_name} (ID: ${match.venue.db_venue_id})`);
                }
                
                // Enable toss simulation
                document.getElementById('use-toss').checked = true;
                
            } else {
                alert('Error loading ESPN match: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            document.getElementById('t20-loading').style.display = 'none';
            console.error('Error loading ESPN match:', error);
            alert('Error loading match data from ESPN');
        }
    }
    
    async function autoFillTeamFromEspn(teamNum, dbTeamName, espnTeam) {
        // Find and select the team by name
        const teamSelect = document.getElementById(`team${teamNum}-select`);
        let teamFound = false;
        let teamId = null;
        
        console.log(`[DEBUG] Team ${teamNum} - Looking for: "${dbTeamName}"`);
        console.log(`[DEBUG] Team ${teamNum} - Dropdown has ${teamSelect.options.length} options`);
        
        // Log first 10 options for debugging
        const availableOptions = Array.from(teamSelect.options).slice(0, 10).map(opt => `"${opt.textContent}"`);
        console.log(`[DEBUG] Team ${teamNum} - First 10 options:`, availableOptions.join(', '));
        
        for (let opt of teamSelect.options) {
            if (opt.textContent === dbTeamName) {
                teamSelect.value = opt.value;
                teamId = opt.value;
                teamFound = true;
                console.log(`[DEBUG] Team ${teamNum} - FOUND match: "${opt.textContent}" (ID: ${opt.value})`);
                break;
            }
        }
        
        if (!teamFound) {
            console.warn(`[DEBUG] Team ${teamNum} - NOT FOUND in dropdown: "${dbTeamName}"`);
            console.warn(`[DEBUG] Team ${teamNum} - All available teams:`, Array.from(teamSelect.options).map(opt => `"${opt.textContent}"`));
            return;
        }
        
        console.log(`[DEBUG] Team ${teamNum} - espnTeam:`, espnTeam);
        console.log(`[DEBUG] Team ${teamNum} - espnTeam.players:`, espnTeam?.players);
        
        // Get matched players from ESPN data
        const matchedPlayers = espnTeam?.players?.filter(p => p.db_player_id) || [];
        
        console.log(`[DEBUG] Team ${teamNum} - matchedPlayers length: ${matchedPlayers.length}`);
        
        // If ESPN has no matched players, fall back to recent lineup from our database
        if (matchedPlayers.length === 0) {
            console.log(`[DEBUG] Team ${teamNum} (${dbTeamName}): No ESPN squad matched to DB, loading recent lineup from database...`);
            await loadPlayers(teamNum);  // Load historical players
            await new Promise(resolve => setTimeout(resolve, 100));
            await loadRecentLineupForTeam(teamNum, teamId);
            return;
        }
        
        // ESPN has matched players - fetch their stats and categorize them properly
        console.log(`[DEBUG] Team ${teamNum} - ESPN provided ${matchedPlayers.length} matched players, fetching stats to categorize...`);
        
        const gender = teamFilters[teamNum].gender;
        const response = await fetch(`/api/players/${teamId}?gender=${gender}`);
        const data = await response.json();
        
        if (!data.success) {
            console.error(`[DEBUG] Team ${teamNum} - Failed to load player stats`);
            return;
        }
        
        // Create maps of player stats
        const batterStats = new Map(data.batters.map(b => [String(b.player_id), b]));
        const bowlerStats = new Map(data.bowlers.map(b => [String(b.player_id), b]));
        
        // Categorize ESPN players into batters and bowlers (no overlap)
        const espnPlayerIds = new Set(matchedPlayers.map(p => String(p.db_player_id)));
        const categorizedBatters = [];
        const categorizedBowlers = [];
        
        for (let playerId of espnPlayerIds) {
            const batterInfo = batterStats.get(playerId);
            const bowlerInfo = bowlerStats.get(playerId);
            
            // Decide category based on stats
            if (batterInfo && bowlerInfo) {
                // All-rounder: prioritize based on primary contribution
                // If they've scored more runs than 20x wickets, they're primarily a batter
                const battingScore = batterInfo.total_runs || 0;
                const bowlingScore = (bowlerInfo.total_wickets || 0) * 20;
                
                if (battingScore >= bowlingScore) {
                    categorizedBatters.push(batterInfo);
                } else {
                    categorizedBowlers.push(bowlerInfo);
                }
            } else if (batterInfo) {
                categorizedBatters.push(batterInfo);
            } else if (bowlerInfo) {
                categorizedBowlers.push(bowlerInfo);
            }
        }
        
        // If we don't have enough players, add from database
        const remainingBatters = data.batters.filter(b => !espnPlayerIds.has(String(b.player_id)) && !bowlerStats.has(String(b.player_id)));
        const remainingBowlers = data.bowlers.filter(b => !espnPlayerIds.has(String(b.player_id)));
        
        // Populate batters dropdown
        const battersSelect = document.getElementById(`team${teamNum}-batters`);
        battersSelect.innerHTML = '';
        
        // Add categorized ESPN batters first (selected)
        categorizedBatters.forEach(b => {
            const opt = document.createElement('option');
            opt.value = b.player_id;
            opt.textContent = `${b.name} (${b.total_runs} runs)`;
            opt.selected = true;
            battersSelect.appendChild(opt);
        });
        
        // Add remaining database batters (unselected)
        remainingBatters.forEach(b => {
            const opt = document.createElement('option');
            opt.value = b.player_id;
            opt.textContent = `${b.name} (${b.total_runs} runs)`;
            battersSelect.appendChild(opt);
        });
        
        // Populate bowlers dropdown
        const bowlersSelect = document.getElementById(`team${teamNum}-bowlers`);
        bowlersSelect.innerHTML = '';
        
        // Add categorized ESPN bowlers first (selected)
        categorizedBowlers.forEach(b => {
            const opt = document.createElement('option');
            opt.value = b.player_id;
            opt.textContent = `${b.name} (${b.total_wickets} wkts)`;
            opt.selected = true;
            bowlersSelect.appendChild(opt);
        });
        
        // Add remaining database bowlers (unselected)
        remainingBowlers.forEach(b => {
            const opt = document.createElement('option');
            opt.value = b.player_id;
            opt.textContent = `${b.name} (${b.total_wickets} wkts)`;
            bowlersSelect.appendChild(opt);
        });
        
        console.log(`[DEBUG] Team ${teamNum} - Categorized ${categorizedBatters.length} batters, ${categorizedBowlers.length} bowlers (no overlap)`);
        console.log(`Team ${teamNum} (${dbTeamName}): Auto-selected ${categorizedBatters.length} batters and ${categorizedBowlers.length} bowlers from ESPN squad`);
    }
    
    async function loadRecentLineupForTeam(teamNum, teamId) {
        // Fetch recent lineup from our database
        try {
            const response = await fetch(`/api/team/${teamId}/recent-lineup?gender=${currentGender}`);
            const data = await response.json();
            
            if (data.success && data.recent_xi && data.recent_xi.length > 0) {
                const battersSelect = document.getElementById(`team${teamNum}-batters`);
                const bowlersSelect = document.getElementById(`team${teamNum}-bowlers`);
                
                // Clear current selections
                for (let opt of battersSelect.options) opt.selected = false;
                for (let opt of bowlersSelect.options) opt.selected = false;
                
                let battersSelected = 0;
                let bowlersSelected = 0;
                
                // Select players from recent XI
                for (let player of data.recent_xi) {
                    const playerId = player.player_id;
                    
                    // Try batters first
                    for (let opt of battersSelect.options) {
                        if (parseInt(opt.value) === playerId && !opt.selected) {
                            opt.selected = true;
                            battersSelected++;
                            break;
                        }
                    }
                    // Also try bowlers
                    for (let opt of bowlersSelect.options) {
                        if (parseInt(opt.value) === playerId && !opt.selected) {
                            opt.selected = true;
                            bowlersSelected++;
                            break;
                        }
                    }
                }
                
                console.log(`Team ${teamNum}: Loaded ${battersSelected} batters, ${bowlersSelected} bowlers from recent DB lineup`);
            } else {
                console.warn(`Team ${teamNum}: No recent lineup found in database`);
            }
        } catch (error) {
            console.error(`Error loading recent lineup for team ${teamNum}:`, error);
        }
    }
    
    async function loadT20MatchById(matchId) {
        if (!matchId) {
            alert('Invalid match ID');
            return;
        }
        
        // Show loading
        document.getElementById('t20-loading').style.display = 'block';
        document.getElementById('t20-match-info').style.display = 'none';
        
        try {
            const response = await fetch(`/api/t20/match/${matchId}`);
            const data = await response.json();
            
            document.getElementById('t20-loading').style.display = 'none';
            
            if (data.from_database && data.match) {
                // DATABASE FALLBACK: No API squad, using recent lineups from our database
                const match = data.match;
                
                // Show match info with database info
                document.getElementById('t20-match-name').textContent = `${match.team1_db_name} vs ${match.team2_db_name}`;
                document.getElementById('t20-match-date').textContent = match.date;
                document.getElementById('t20-team1-info').textContent = `${match.team1_players.length} from last match (${match.team1_last_match || 'N/A'})`;
                document.getElementById('t20-team2-info').textContent = `${match.team2_players.length} from last match (${match.team2_last_match || 'N/A'})`;
                document.getElementById('t20-match-info').style.display = 'block';
                
                // Show info message
                console.log(`Using database lineups: ${match.team1_db_name} (${match.team1_recent_xi.length} players), ${match.team2_db_name} (${match.team2_recent_xi.length} players)`);
                
                // Auto-fill teams using database recent XI
                await autoFillTeamFromDB(1, match.team1_db_name, match.team1_recent_xi);
                await autoFillTeamFromDB(2, match.team2_db_name, match.team2_recent_xi);
                
                // Auto-select venue if found
                if (match.venue_db_id) {
                    const venueSelect = document.getElementById('venue-select');
                    venueSelect.value = match.venue_db_id;
                    console.log(`Auto-selected venue: ${match.venue_db_name} (ID: ${match.venue_db_id})`);
                }
                
                // Enable toss simulation
                document.getElementById('use-toss').checked = true;
                
            } else if (data.success && data.match) {
                // API SQUAD: Full squad data from Cricket Data API
                const match = data.match;
                
                // Show match info
                document.getElementById('t20-match-name').textContent = `${match.team1_db_name} vs ${match.team2_db_name}`;
                document.getElementById('t20-match-date').textContent = match.date;
                
                const matched1 = match.team1_squad.filter(p => p.matched).length;
                const matched2 = match.team2_squad.filter(p => p.matched).length;
                document.getElementById('t20-team1-info').textContent = `${matched1}/${match.team1_squad.length} players`;
                document.getElementById('t20-team2-info').textContent = `${matched2}/${match.team2_squad.length} players`;
                document.getElementById('t20-match-info').style.display = 'block';
                
                // Auto-fill teams
                await autoFillTeam(1, match.team1_db_name, match.team1_squad, match.team1_suggested_xi);
                await autoFillTeam(2, match.team2_db_name, match.team2_squad, match.team2_suggested_xi);
                
                // Auto-select venue if we found a match
                if (match.venue_db_id) {
                    const venueSelect = document.getElementById('venue-select');
                    venueSelect.value = match.venue_db_id;
                    console.log(`Auto-selected venue: ${match.venue_db_name} (ID: ${match.venue_db_id})`);
                }
                
                // Enable toss simulation for upcoming matches
                document.getElementById('use-toss').checked = true;
                
            } else {
                alert('Error loading match: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            document.getElementById('t20-loading').style.display = 'none';
            console.error('Error loading T20 match:', error);
            alert('Error loading match data');
        }
    }
    
    // Legacy WBBL functions (kept for backward compatibility)
    async function loadWBBLFixtures() {
        // Redirect to the new series-based loader
        console.log('Legacy loadWBBLFixtures called - use loadT20Series instead');
    }
    
    async function loadWBBLMatch() {
        // Redirect to the new T20 loader
        console.log('Legacy loadWBBLMatch called - use loadT20Match instead');
    }
    
    async function autoFillTeamFromDB(teamNum, teamName, recentXI) {
        // Find and select the team by name
        const teamSelect = document.getElementById(`team${teamNum}-select`);
        let teamFound = false;
        
        for (let opt of teamSelect.options) {
            if (opt.textContent === teamName) {
                teamSelect.value = opt.value;
                teamFound = true;
                break;
            }
        }
        
        if (!teamFound) {
            console.warn(`Team not found in dropdown: ${teamName}`);
            return;
        }
        
        // Load players for this team
        await loadPlayers(teamNum);
        
        // Small delay to ensure DOM is updated
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Select the recent XI players
        const battersSelect = document.getElementById(`team${teamNum}-batters`);
        const bowlersSelect = document.getElementById(`team${teamNum}-bowlers`);
        
        // Clear current selections
        for (let opt of battersSelect.options) opt.selected = false;
        for (let opt of bowlersSelect.options) opt.selected = false;
        
        let battersSelected = 0;
        let bowlersSelected = 0;
        
        // Select players from recent XI (first in batters, then in bowlers)
        for (let playerId of recentXI) {
            // Try batters first
            for (let opt of battersSelect.options) {
                if (parseInt(opt.value) === playerId && !opt.selected) {
                    opt.selected = true;
                    battersSelected++;
                    break;
                }
            }
            // If not in batters (or not selected), try bowlers
            let foundInBatters = Array.from(battersSelect.options).some(opt => parseInt(opt.value) === playerId && opt.selected);
            if (!foundInBatters) {
                for (let opt of bowlersSelect.options) {
                    if (parseInt(opt.value) === playerId && !opt.selected) {
                        opt.selected = true;
                        bowlersSelected++;
                        break;
                    }
                }
            }
        }
        
        console.log(`Team ${teamNum} (${teamName}): Selected ${battersSelected} batters, ${bowlersSelected} bowlers from recent XI`);
    }
    
    async function autoFillTeam(teamNum, teamName, squad, suggestedXI) {
        // Find and select the team
        const teamSelect = document.getElementById(`team${teamNum}-select`);
        for (let opt of teamSelect.options) {
            if (opt.textContent === teamName) {
                teamSelect.value = opt.value;
                break;
            }
        }
        
        // Load players for this team
        await loadPlayers(teamNum);
        
        // Small delay to ensure DOM is updated
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Select the suggested XI in batters list
        const battersSelect = document.getElementById(`team${teamNum}-batters`);
        const bowlersSelect = document.getElementById(`team${teamNum}-bowlers`);
        
        // Clear current selections
        for (let opt of battersSelect.options) opt.selected = false;
        for (let opt of bowlersSelect.options) opt.selected = false;
        
        // Select suggested players
        let battersSelected = 0;
        let bowlersSelected = 0;
        
        for (let playerId of suggestedXI) {
            // Try to select in batters list
            for (let opt of battersSelect.options) {
                if (parseInt(opt.value) === playerId && battersSelected < 11) {
                    opt.selected = true;
                    battersSelected++;
                    break;
                }
            }
            
            // Also try bowlers list
            for (let opt of bowlersSelect.options) {
                if (parseInt(opt.value) === playerId && bowlersSelected < 5) {
                    opt.selected = true;
                    bowlersSelected++;
                }
            }
        }
        
        console.log(`Team ${teamNum}: Selected ${battersSelected} batters, ${bowlersSelected} bowlers`);
    }
    
    async function loadTeams() {
        // Legacy function - now loads teams for both panels
        await loadTeamsForTeam(1);
        await loadTeamsForTeam(2);
    }
    
    async function loadVenues() {
        try {
            const response = await fetch(`/api/venues?gender=${currentGender}&min_matches=3`);
            const data = await response.json();
            
            console.log('Venues API response:', data.success, 'hierarchical:', !!data.venues_hierarchical, 'countries:', data.venues_hierarchical?.length);
            
            if (data.success && data.venues_hierarchical) {
                const venueSelect = document.getElementById('venue-select');
                if (!venueSelect) {
                    console.error('venue-select element not found!');
                    return;
                }
                venueSelect.innerHTML = '<option value="">-- Neutral Venue --</option>';
                
                let totalVenues = 0;
                // Use hierarchical data for grouped dropdown
                data.venues_hierarchical.forEach(country => {
                    // Create optgroup for each country
                    const countryGroup = document.createElement('optgroup');
                    countryGroup.label = `${country.flag} ${country.name}`;
                    
                    country.cities.forEach(city => {
                        city.venues.forEach(venue => {
                            const opt = document.createElement('option');
                            opt.value = venue.venue_id;
                            // Format: "City ‚Ä¢ Venue Name (X matches)"
                            opt.textContent = `${city.name} ‚Ä¢ ${venue.name} (${venue.match_count})`;
                            countryGroup.appendChild(opt);
                            totalVenues++;
                        });
                    });
                    
                    if (countryGroup.children.length > 0) {
                        venueSelect.appendChild(countryGroup);
                    }
                });
                console.log('Loaded', totalVenues, 'venues into dropdown');
            } else if (data.success && data.venues) {
                // Fallback to flat list
                const venueSelect = document.getElementById('venue-select');
                venueSelect.innerHTML = '<option value="">-- Neutral Venue --</option>';
                data.venues.forEach(v => {
                    const opt = document.createElement('option');
                    opt.value = v.venue_id;
                    opt.textContent = `${v.name}${v.city ? ', ' + v.city : ''} (${v.match_count} matches)`;
                    venueSelect.appendChild(opt);
                });
            }
        } catch (error) {
            console.error('Error loading venues:', error);
        }
    }
    
    // Load players directly from a matched squad (for franchise teams where team doesn't match DB)
    async function loadPlayersFromSquad(teamNum, squadPlayers, teamName) {
        console.log(`[loadPlayersFromSquad] Loading ${squadPlayers.length} players for team ${teamNum} (${teamName})`);
        
        // Get matched players with db_player_id
        const matchedPlayerIds = squadPlayers
            .filter(p => p.db_player_id)
            .map(p => p.db_player_id);
        
        if (matchedPlayerIds.length === 0) {
            console.log(`[loadPlayersFromSquad] No matched players for team ${teamNum}`);
            return;
        }
        
        try {
            // Fetch stats for these specific players
            const response = await fetch(`/api/players/by-ids`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    player_ids: matchedPlayerIds,
                    gender: currentGender
                })
            });
            const data = await response.json();
            
            if (data.success) {
                // Create a lookup map
                const playerStats = new Map(data.players.map(p => [p.player_id, p]));
                
                // Populate batter dropdown
                const battersSelect = document.getElementById(`team${teamNum}-batters`);
                battersSelect.innerHTML = '';
                
                // Populate bowler dropdown
                const bowlersSelect = document.getElementById(`team${teamNum}-bowlers`);
                bowlersSelect.innerHTML = '';
                
                let battersAdded = 0;
                let bowlersAdded = 0;
                
                // Add matched players based on their roles
                squadPlayers.forEach(squadPlayer => {
                    if (!squadPlayer.db_player_id) return;
                    
                    const stats = playerStats.get(squadPlayer.db_player_id);
                    if (!stats) return;
                    
                    const playerName = stats.name || squadPlayer.name;
                    
                    // Add to batters if they have batting stats or are marked as batter
                    const isBatter = squadPlayer.role === 'Batter' || 
                                     squadPlayer.role === 'All Rounder' ||
                                     squadPlayer.role === 'WK' ||
                                     stats.total_runs > 0;
                    
                    // Add to bowlers if they have bowling stats or are marked as bowler
                    const isBowler = squadPlayer.role === 'Bowler' || 
                                     squadPlayer.role === 'All Rounder' ||
                                     stats.total_wickets > 0;
                    
                    if (isBatter && battersAdded < 11) {
                        const opt = document.createElement('option');
                        opt.value = squadPlayer.db_player_id;
                        opt.textContent = `${playerName} (${stats.total_runs || 0} runs)`;
                        opt.selected = battersAdded < 6;  // Auto-select first 6
                        battersSelect.appendChild(opt);
                        battersAdded++;
                    }
                    
                    if (isBowler && bowlersAdded < 11) {
                        const opt = document.createElement('option');
                        opt.value = squadPlayer.db_player_id;
                        opt.textContent = `${playerName} (${stats.total_wickets || 0} wkts)`;
                        opt.selected = bowlersAdded < 5;  // Auto-select first 5
                        bowlersSelect.appendChild(opt);
                        bowlersAdded++;
                    }
                });
                
                console.log(`[loadPlayersFromSquad] Added ${battersAdded} batters, ${bowlersAdded} bowlers for ${teamName}`);
                
                // Update source badge
                updateSourceBadge(teamNum, 'crex_squad_optimized', 'medium', battersAdded);
                
                // Store for reference
                window[`team${teamNum}Players`] = data.players;
            }
        } catch (error) {
            console.error(`[loadPlayersFromSquad] Error:`, error);
        }
    }
    
    // Track loading state to prevent infinite loops
    const loadingPlayers = {1: false, 2: false};
    
    async function loadPlayers(teamNum) {
        // Prevent recursive calls
        if (loadingPlayers[teamNum]) {
            console.log(`[loadPlayers] Already loading for team ${teamNum}, skipping`);
            return;
        }
        
        const teamId = document.getElementById(`team${teamNum}-select`).value;
        if (!teamId) return;
        
        console.log(`[loadPlayers] Team ${teamNum}, ID: ${teamId}`);
        
        loadingPlayers[teamNum] = true;
        
        try {
            // Use the team-specific gender filter
            const gender = teamFilters[teamNum].gender;
            const response = await fetch(`/api/players/${teamId}?gender=${gender}`);
            const data = await response.json();
            
            if (data.success) {
                let filteredPlayers = data.players;
                let filteredGrouped = data.grouped_by_role;
                
                // Filter by ESPN squad if available
                const espnSquad = window.espnSquadData?.[`team${teamNum}`] || [];
                if (espnSquad.length > 0) {
                    // Get squad player IDs (both ESPN IDs and DB IDs)
                    const squadDbIds = espnSquad
                        .map(p => p.db_player_id)
                        .filter(id => id != null);
                    
                    console.log(`[loadPlayers] üéØ Filtering to ESPN squad: ${squadDbIds.length} matched players from ${espnSquad.length} ESPN players`);
                    
                    // Filter players to only those in the squad
                    // Also include any players that might have been matched but not yet in espnSquadData
                    filteredPlayers = data.players.filter(p => {
                        // Include if in matched squad
                        if (squadDbIds.includes(p.player_id)) {
                            return true;
                        }
                        // Also include if this player has an ESPN ID that matches the squad
                        const espnMatch = espnSquad.find(espn => espn.espn_id === p.espn_player_id);
                        if (espnMatch) {
                            // Update espnSquadData with this match
                            espnMatch.db_player_id = p.player_id;
                            return true;
                        }
                        return false;
                    });
                    
                    // Re-group filtered players by role
                    filteredGrouped = {
                        KEEPER: filteredPlayers.filter(p => p.role_category === 'KEEPER'),
                        BATTER: filteredPlayers.filter(p => p.role_category === 'BATTER'),
                        ALLROUNDER: filteredPlayers.filter(p => p.role_category === 'ALLROUNDER'),
                        BOWLER: filteredPlayers.filter(p => p.role_category === 'BOWLER')
                    };
                    
                    console.log(`[loadPlayers] ‚úÖ Squad filtered: ${filteredPlayers.length} players (K:${filteredGrouped.KEEPER.length}, B:${filteredGrouped.BATTER.length}, A:${filteredGrouped.ALLROUNDER.length}, Bo:${filteredGrouped.BOWLER.length})`);
                    
                    // Show squad filter badge
                    const squadBadge = document.getElementById(`team${teamNum}-squad-badge`);
                    const squadText = document.getElementById(`team${teamNum}-squad-text`);
                    if (squadBadge && squadText) {
                        squadText.textContent = `ESPN Squad Only (${filteredPlayers.length} players)`;
                        squadBadge.style.display = 'inline-flex';
                    }
                } else {
                    console.log(`[loadPlayers] ‚ö†Ô∏è No ESPN squad data - showing all ${data.players.length} players`);
                    
                    // Hide squad filter badge
                    const squadBadge = document.getElementById(`team${teamNum}-squad-badge`);
                    if (squadBadge) {
                        squadBadge.style.display = 'none';
                    }
                }
                
                // Store players for this team
                window[`team${teamNum}Players`] = filteredPlayers;
                window[`team${teamNum}GroupedPlayers`] = filteredGrouped;
                
                // Populate role-based dropdowns
                populateRoleDropdowns(teamNum, filteredGrouped);
                
                console.log(`[loadPlayers] Loaded ${filteredPlayers.length} players for team ${teamNum}`);
            }
        } finally {
            loadingPlayers[teamNum] = false;
        }
    }
    
    function populateRoleDropdowns(teamNum, grouped) {
        // Keepers
        const keepersSelect = document.getElementById(`team${teamNum}-keepers`);
        keepersSelect.innerHTML = '';
        (grouped.KEEPER || []).forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.player_id;
            opt.textContent = `${p.name} (${p.stats.runs} runs, ${p.stats.stumpings || 0} st)`;
            keepersSelect.appendChild(opt);
        });
        
        // Batters
        const battersSelect = document.getElementById(`team${teamNum}-batters`);
        battersSelect.innerHTML = '';
        (grouped.BATTER || []).forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.player_id;
            opt.textContent = `${p.name} (${p.stats.runs} runs, avg ${p.stats.avg})`;
            battersSelect.appendChild(opt);
        });
        
        // All-rounders
        const allroundersSelect = document.getElementById(`team${teamNum}-allrounders`);
        allroundersSelect.innerHTML = '';
        (grouped.ALLROUNDER || []).forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.player_id;
            opt.textContent = `${p.name} (${p.stats.runs}r, ${p.stats.wickets}w)`;
            allroundersSelect.appendChild(opt);
        });
        
        // Bowlers
        const bowlersSelect = document.getElementById(`team${teamNum}-bowlers`);
        bowlersSelect.innerHTML = '';
        (grouped.BOWLER || []).forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.player_id;
            opt.textContent = `${p.name} (${p.stats.wickets} wkts)`;
            bowlersSelect.appendChild(opt);
        });
    }
    
    function selectTop(selectEl, n) {
        const options = selectEl.options;
        for (let i = 0; i < Math.min(n, options.length); i++) {
            options[i].selected = true;
        }
    }
    
    function validateTeamSelection(teamNum) {
        // Get selected players from all role dropdowns
        const keepers = getSelectedValues(`team${teamNum}-keepers`);
        const batters = getSelectedValues(`team${teamNum}-batters`);
        const allrounders = getSelectedValues(`team${teamNum}-allrounders`);
        const bowlers = getSelectedValues(`team${teamNum}-bowlers`);
        
        const total = keepers.length + batters.length + allrounders.length + bowlers.length;
        const bowlingOptions = allrounders.length + bowlers.length;
        
        const errors = [];
        const warnings = [];
        
        // Validation rules
        if (keepers.length !== 1) {
            errors.push(`Must select exactly 1 wicketkeeper (have ${keepers.length})`);
        }
        // Bowling requirement: Either 4+ specialist bowlers OR 5+ total bowling options
        if (bowlers.length < 4 && bowlingOptions < 5) {
            errors.push(`Need either 4+ specialist bowlers OR 5+ total bowling options (have ${bowlers.length} bowlers, ${bowlingOptions} total)`);
        }
        if (total !== 11) {
            errors.push(`Must select exactly 11 players (have ${total})`);
        }
        
        // Warnings
        if (batters.length > 7) {
            warnings.push(`Team has ${batters.length} specialist batters (recommended max: 7)`);
        }
        
        // Display validation summary
        const validationDiv = document.getElementById(`team${teamNum}-validation`);
        if (errors.length > 0 || warnings.length > 0) {
            validationDiv.style.display = 'block';
            validationDiv.className = `validation-summary ${errors.length > 0 ? 'invalid' : 'valid'}`;
            
            let html = '';
            errors.forEach(err => {
                html += `<div class="validation-item invalid"><span class="icon">‚úó</span><span>${err}</span></div>`;
            });
            warnings.forEach(warn => {
                html += `<div class="validation-item warning"><span class="icon">‚ö†</span><span>${warn}</span></div>`;
            });
            if (errors.length === 0) {
                html += `<div class="validation-item valid"><span class="icon">‚úì</span><span>Team selection valid (${total}/11 players)</span></div>`;
            }
            
            validationDiv.innerHTML = html;
        } else {
            validationDiv.style.display = 'none';
        }
        
        // Update predict button state
        const isValid = errors.length === 0;
        updatePredictButtonState();
        
        return isValid;
    }
    
    function updatePredictButtonState() {
        // Check validation state WITHOUT re-running validation (avoid recursion)
        const team1Errors = checkTeamErrors(1);
        const team2Errors = checkTeamErrors(2);
        
        // Also check if venue is selected
        const venueSelected = document.getElementById('venue-select').value !== '';
        
        // Enable predict button only if all valid
        const predictBtn = document.querySelector('button[onclick="runSimulation()"]');
        if (predictBtn) {
            predictBtn.disabled = !(team1Errors.length === 0 && team2Errors.length === 0 && venueSelected);
        }
    }
    
    function checkTeamErrors(teamNum) {
        // Just check for errors without updating UI
        const keepers = getSelectedValues(`team${teamNum}-keepers`);
        const batters = getSelectedValues(`team${teamNum}-batters`);
        const allrounders = getSelectedValues(`team${teamNum}-allrounders`);
        const bowlers = getSelectedValues(`team${teamNum}-bowlers`);
        
        const total = keepers.length + batters.length + allrounders.length + bowlers.length;
        const bowlingOptions = allrounders.length + bowlers.length;
        
        const errors = [];
        if (keepers.length !== 1) errors.push(`Must select exactly 1 wicketkeeper (have ${keepers.length})`);
        // Bowling requirement: Either 4+ specialist bowlers OR 5+ total bowling options
        if (bowlers.length < 4 && bowlingOptions < 5) {
            errors.push(`Need either 4+ specialist bowlers OR 5+ total bowling options (have ${bowlers.length} bowlers, ${bowlingOptions} total)`);
        }
        if (total !== 11) errors.push(`Must select exactly 11 players (have ${total})`);
        
        return errors;
    }
    
    function updateSourceBadge(teamNum, source, confidence, playerCount = null) {
        const badge = document.getElementById(`team${teamNum}-source-badge`);
        const icon = document.getElementById(`team${teamNum}-source-icon`);
        const text = document.getElementById(`team${teamNum}-source-text`);
        
        const icons = {
            'espn_xi': '‚úì',
            'espn_squad_optimized': '‚öô',
            'crex_xi': '‚úì',
            'crex_squad_optimized': '‚öô',
            'database_last_match': 'üìä',
            'fallback': '‚ö†'
        };
        
        const labels = {
            'espn_xi': 'ESPN Playing XI',
            'espn_squad_optimized': 'Optimized from Squad',
            'crex_xi': 'CREX Playing XI',
            'crex_squad_optimized': 'Optimized from Squad',
            'database_last_match': 'Last Match Lineup',
            'fallback': 'Best Available Players'
        };
        
        icon.textContent = icons[source] || 'üîÑ';
        let labelText = labels[source] || 'Loading...';
        if (playerCount !== null) {
            labelText += ` (${playerCount}/11)`;
        }
        text.textContent = labelText;
        badge.style.display = 'inline-flex';
        
        // Color based on confidence
        if (confidence === 'high') {
            badge.style.background = '#10b981';
        } else if (confidence === 'medium') {
            badge.style.background = '#f59e0b';
        } else {
            badge.style.background = '#ef4444';
        }
    }
    
    async function waterfallLoadTeam(teamNum, matchId, teamId, matchUrl = null) {
        console.log(`[waterfallLoadTeam] Team ${teamNum}, Match: ${matchId}, Team ID: ${teamId}, URL: ${matchUrl}`);
        
        const gender = teamFilters[teamNum].gender;
        
        try {
            let url = `/api/team/waterfall-select?team_num=${teamNum}&team_id=${teamId}&gender=${gender}`;
            if (matchUrl) {
                url += `&match_url=${encodeURIComponent(matchUrl)}`;
            }
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.success) {
                const sourceLabels = {
                    'espn_xi': '‚úÖ ESPN Playing XI',
                    'espn_squad_optimized': '‚öôÔ∏è Optimized from ESPN Squad',
                    'crex_xi': '‚úÖ CREX Playing XI',
                    'crex_squad_optimized': '‚öôÔ∏è Optimized from CREX Squad',
                    'database_last_match': 'üìä Last Match from Database',
                    'fallback': '‚ö†Ô∏è Best Available Players'
                };
                
                console.log(`[waterfallLoadTeam] Source: ${sourceLabels[data.source] || data.source}`);
                console.log(`[waterfallLoadTeam] Players found: ${data.players.length}/11`);
                
                // Update source badge with player count
                updateSourceBadge(teamNum, data.source, data.confidence, data.players.length);
                
                // Update espnSquadData with the actual matched players from backend
                // This ensures frontend filtering matches backend optimizer (works for both ESPN and CREX)
                const isExternalSquadSource = ['espn_playing_xi', 'espn_squad_optimized', 'crex_xi', 'crex_squad_optimized'].includes(data.source);
                if (isExternalSquadSource) {
                    const matchedPlayerIds = data.players.map(p => p.player_id);
                    const alternatives = data.alternatives || [];
                    const allMatchedIds = [...matchedPlayerIds, ...alternatives.map(p => p.player_id)];
                    
                    // Update espnSquadData to include all matched players (shared structure for ESPN and CREX)
                    if (window.espnSquadData && window.espnSquadData[`team${teamNum}`]) {
                        // Update each squad player with their matched db_player_id
                        window.espnSquadData[`team${teamNum}`].forEach(squadPlayer => {
                            // Check if this player was matched - use external_id which works for both ESPN and CREX
                            const externalId = squadPlayer.espn_id || squadPlayer.crex_id;
                            const matched = [...data.players, ...alternatives].find(p => p.external_id === externalId);
                            if (matched) {
                                squadPlayer.db_player_id = matched.player_id;
                            }
                        });
                        console.log(`[waterfallLoadTeam] Updated squadData for team ${teamNum}: ${window.espnSquadData[`team${teamNum}`].filter(p => p.db_player_id).length}/${window.espnSquadData[`team${teamNum}`].length} players matched`);
                    }
                }
                
                // Load all available players first (will use updated espnSquadData)
                await loadPlayers(teamNum);
                
                // Small delay to ensure DOM is updated
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Then select the waterfall-selected players
                selectPlayersByIds(teamNum, data.players);
                
                // Validate after a short delay to ensure selection is complete
                setTimeout(() => {
                    validateTeamSelection(teamNum);
                }, 200);
                
                // Show warning if incomplete team
                if (data.players.length < 11) {
                    console.warn(`[waterfallLoadTeam] ‚ö†Ô∏è Only ${data.players.length} players auto-selected. Please complete the team manually or click "Re-optimize from Squad".`);
                }
            }
        } catch (error) {
            console.error(`[waterfallLoadTeam] Error: ${error}`);
            // Fall back to regular load
            await loadPlayers(teamNum);
        }
    }
    
    function selectPlayersByIds(teamNum, players) {
        console.log(`[selectPlayersByIds] Selecting ${players.length} players for team ${teamNum}:`, players.map(p => `${p.name} (${p.role_category})`));
        
        // Group players by role
        const grouped = {
            KEEPER: [],
            BATTER: [],
            ALLROUNDER: [],
            BOWLER: []
        };
        
        players.forEach(p => {
            const category = p.role_category;
            if (grouped[category]) {
                grouped[category].push(p.player_id);
            } else {
                console.warn(`[selectPlayersByIds] Unknown role category: ${category} for player ${p.name}`);
            }
        });
        
        console.log(`[selectPlayersByIds] Grouped:`, grouped);
        
        // Select in each dropdown
        const keepersSelected = selectInDropdown(`team${teamNum}-keepers`, grouped.KEEPER);
        const battersSelected = selectInDropdown(`team${teamNum}-batters`, grouped.BATTER);
        const allroundersSelected = selectInDropdown(`team${teamNum}-allrounders`, grouped.ALLROUNDER);
        const bowlersSelected = selectInDropdown(`team${teamNum}-bowlers`, grouped.BOWLER);
        
        console.log(`[selectPlayersByIds] Selected: ${keepersSelected} keepers, ${battersSelected} batters, ${allroundersSelected} all-rounders, ${bowlersSelected} bowlers`);
        
        // Trigger change events to update validation
        ['keepers', 'batters', 'allrounders', 'bowlers'].forEach(role => {
            const select = document.getElementById(`team${teamNum}-${role}`);
            if (select) {
                select.dispatchEvent(new Event('change', { bubbles: true }));
            }
        });
    }
    
    function selectInDropdown(selectId, playerIds) {
        const select = document.getElementById(selectId);
        if (!select) {
            console.warn(`[selectInDropdown] Select element not found: ${selectId}`);
            return 0;
        }
        
        if (playerIds.length === 0) {
            // Clear selection
            Array.from(select.options).forEach(opt => opt.selected = false);
            // For single-select, also clear the selectedIndex
            if (!select.multiple) {
                select.selectedIndex = -1;
            }
            return 0;
        }
        
        // Clear existing selection
        Array.from(select.options).forEach(opt => opt.selected = false);
        if (!select.multiple) {
            select.selectedIndex = -1;
        }
        
        let selectedCount = 0;
        // Select matching players
        playerIds.forEach(playerId => {
            let found = false;
            Array.from(select.options).forEach((opt, index) => {
                const optValue = parseInt(opt.value);
                if (optValue === playerId) {
                    opt.selected = true;
                    found = true;
                    selectedCount++;
                    // For single-select, also set selectedIndex
                    if (!select.multiple && select.selectedIndex === -1) {
                        select.selectedIndex = index;
                    }
                }
            });
            if (!found) {
                console.warn(`[selectInDropdown] Player ID ${playerId} not found in ${selectId} dropdown (has ${select.options.length} options)`);
            }
        });
        
        // For single-select, only select the first one
        if (!select.multiple && selectedCount > 1) {
            console.warn(`[selectInDropdown] Single-select dropdown ${selectId} had ${selectedCount} players to select, only selecting first`);
            // Clear all and select only first
            Array.from(select.options).forEach(opt => opt.selected = false);
            const firstId = playerIds[0];
            Array.from(select.options).forEach((opt, index) => {
                if (parseInt(opt.value) === firstId) {
                    opt.selected = true;
                    select.selectedIndex = index;
                }
            });
            selectedCount = 1;
        }
        
        console.log(`[selectInDropdown] Selected ${selectedCount} players in ${selectId} (multiple: ${select.multiple})`);
        return selectedCount;
    }
    
    async function reOptimizeTeam(teamNum) {
        const teamId = document.getElementById(`team${teamNum}-select`).value;
        if (!teamId) {
            alert('Please select a team first');
            return;
        }
        
        // Get available players (filtered by ESPN squad if available)
        let allPlayers = window[`team${teamNum}Players`] || [];
        
        console.log(`[reOptimizeTeam] Current players available: ${allPlayers.length}`);
        
        // If we have fewer than 11, try to reload from ESPN squad
        if (allPlayers.length < 11) {
            // Check if we have ESPN squad data that might have more players
            const espnSquad = window.espnSquadData?.[`team${teamNum}`] || [];
            if (espnSquad.length >= 11) {
                // Reload players to get full ESPN squad
                console.log(`[reOptimizeTeam] Reloading players to get full ESPN squad (${espnSquad.length} players)`);
                await loadPlayers(teamNum);
                const reloadedPlayers = window[`team${teamNum}Players`] || [];
                if (reloadedPlayers.length < 11) {
                    alert(`Not enough players available to optimize (have ${reloadedPlayers.length}, need 11)`);
                    return;
                }
            } else {
                alert(`Not enough players available to optimize (have ${allPlayers.length}, need 11)`);
                return;
            }
        }
        
        // Get updated players after potential reload
        const playersToUse = window[`team${teamNum}Players`] || [];
        if (playersToUse.length < 11) {
            alert(`Not enough players available to optimize (have ${playersToUse.length}, need 11)`);
            return;
        }
        
        const gender = teamFilters[teamNum].gender;
        const squadIds = playersToUse.map(p => p.player_id);
        
        console.log(`[reOptimizeTeam] Optimizing from ${squadIds.length} players for team ${teamNum}`);
        
        try {
            const response = await fetch('/api/team/optimize', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    squad_player_ids: squadIds,
                    team_id: teamId,
                    gender: gender
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                console.log(`[reOptimizeTeam] Optimized XI: ${data.optimized_xi.length} players`);
                
                // Small delay to ensure dropdowns are ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                selectPlayersByIds(teamNum, data.optimized_xi);
                // Use source based on current data source
                const sourceLabel = currentDataSource === 'crex' ? 'crex_squad_optimized' : 'espn_squad_optimized';
                updateSourceBadge(teamNum, sourceLabel, 'high', data.optimized_xi.length);
                
                // Validate after selection
                setTimeout(() => {
                    validateTeamSelection(teamNum);
                }, 200);
                
                console.log(`[reOptimizeTeam] Successfully optimized team ${teamNum}`);
            } else {
                alert(`Failed to optimize: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error(`[reOptimizeTeam] Error: ${error}`);
            alert('Failed to optimize team: ' + error.message);
        }
    }
    
    async function loadLastMatch(teamNum) {
        const teamId = document.getElementById(`team${teamNum}-select`).value;
        if (!teamId) {
            alert('Please select a team first');
            return;
        }
        
        const gender = teamFilters[teamNum].gender;
        
        try {
            const response = await fetch(`/api/team/${teamId}/recent-lineup?gender=${gender}`);
            const data = await response.json();
            
            if (data.success && data.players.length > 0) {
                selectPlayersByIds(teamNum, data.players);
                updateSourceBadge(teamNum, 'database_last_match', 'medium');
                validateTeamSelection(teamNum);
                console.log(`[loadLastMatch] Loaded last match for team ${teamNum}`);
            } else {
                alert('No recent match data available for this team');
            }
        } catch (error) {
            console.error(`[loadLastMatch] Error: ${error}`);
            alert('Failed to load last match lineup');
        }
    }
    
    function clearSquadData(teamNum) {
        // Clear ESPN squad filter when manually changing team
        if (window.espnSquadData) {
            window.espnSquadData[`team${teamNum}`] = [];
        }
        const squadBadge = document.getElementById(`team${teamNum}-squad-badge`);
        if (squadBadge) {
            squadBadge.style.display = 'none';
        }
    }
    
    function clearTeam(teamNum) {
        ['keepers', 'batters', 'allrounders', 'bowlers'].forEach(role => {
            const select = document.getElementById(`team${teamNum}-${role}`);
            if (select) {
                Array.from(select.options).forEach(opt => opt.selected = false);
            }
        });
        
        document.getElementById(`team${teamNum}-source-badge`).style.display = 'none';
        clearSquadData(teamNum);
        validateTeamSelection(teamNum);
    }
    
    function getSelectedValues(selectId) {
        const select = document.getElementById(selectId);
        return Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
    }
    
    async function runSimulation() {
        // Get team names from panel data or dropdown
        const team1Name = teamPlayerData[1].teamName || document.getElementById('team1-select').selectedOptions[0]?.text || 'Team 1';
        const team2Name = teamPlayerData[2].teamName || document.getElementById('team2-select').selectedOptions[0]?.text || 'Team 2';
        
        // Get players from the new panel system
        const team1Selected = teamPlayerData[1].selected;
        const team2Selected = teamPlayerData[2].selected;
        
        if (team1Selected.length === 0 || team2Selected.length === 0) {
            alert('Please select players for both teams');
            return;
        }
        
        if (team1Selected.length < 11 || team2Selected.length < 11) {
            const proceed = confirm(`Teams are incomplete (${team1Selected.length}/11 and ${team2Selected.length}/11). Continue anyway?`);
            if (!proceed) return;
        }
        
        // Extract player IDs from panel data
        const uniqueTeam1Batters = team1Selected.map(p => String(p.db_player_id || p.player_id || p.id));
        const uniqueTeam2Batters = team2Selected.map(p => String(p.db_player_id || p.player_id || p.id));
        
        // Determine bowlers (role = BOWL or AR)
        const uniqueTeam1Bowlers = team1Selected
            .filter(p => {
                const role = normalizeRole(p.role || p.player_role);
                return role === 'BOWL' || role === 'AR';
            })
            .map(p => String(p.db_player_id || p.player_id || p.id));
        
        const uniqueTeam2Bowlers = team2Selected
            .filter(p => {
                const role = normalizeRole(p.role || p.player_role);
                return role === 'BOWL' || role === 'AR';
            })
            .map(p => String(p.db_player_id || p.player_id || p.id));
        
        console.log(`Team 1: ${uniqueTeam1Batters.length} batters, ${uniqueTeam1Bowlers.length} bowlers`);
        console.log(`Team 2: ${uniqueTeam2Batters.length} batters, ${uniqueTeam2Bowlers.length} bowlers`);
        
        // Get venue and toss options
        const venueSelect = document.getElementById('venue-select');
        const venueId = venueSelect.value ? parseInt(venueSelect.value) : null;
        const useToss = document.getElementById('use-toss').checked;
        const nSimulations = parseInt(document.getElementById('n-simulations').value);
        
        // Show loading with progress
        document.getElementById('loading').style.display = 'block';
        document.getElementById('results').style.display = 'none';
        document.getElementById('scorecard-section').style.display = 'none';
        
        // Reset progress UI
        document.getElementById('progress-fill').style.width = '0%';
        document.getElementById('progress-count').textContent = '0';
        document.getElementById('progress-rate').textContent = '--';
        document.getElementById('progress-eta').textContent = '--';
        document.getElementById('progress-status').textContent = `Starting ${nSimulations.toLocaleString()} simulations...`;
        
        // Smooth animation state
        let displayedCount = 0;
        let targetCount = 0;
        let currentRate = 100; // Default estimate: 100 sims/sec
        let animationInterval = null;
        let simulationComplete = false;
        
        // Start smooth animation loop (updates every 50ms)
        animationInterval = setInterval(() => {
            if (simulationComplete) {
                clearInterval(animationInterval);
                return;
            }
            
            // Smoothly increment towards target
            if (displayedCount < targetCount) {
                // Increment based on estimated rate
                const increment = currentRate / 20; // 50ms = 1/20 second
                displayedCount = Math.min(displayedCount + increment, targetCount);
                
                const pct = (displayedCount / nSimulations) * 100;
                const eta = currentRate > 0 ? (nSimulations - displayedCount) / currentRate : 0;
                
                document.getElementById('progress-fill').style.width = pct.toFixed(1) + '%';
                document.getElementById('progress-count').textContent = Math.round(displayedCount).toLocaleString();
                document.getElementById('progress-rate').textContent = Math.round(currentRate).toLocaleString();
                document.getElementById('progress-eta').textContent = eta.toFixed(1);
                document.getElementById('progress-status').textContent = 
                    `${Math.round(displayedCount).toLocaleString()} / ${nSimulations.toLocaleString()} simulations (${pct.toFixed(1)}%)`;
            }
        }, 50);
        
        const payload = {
            team1_batters: uniqueTeam1Batters,
            team1_bowlers: uniqueTeam1Bowlers,
            team2_batters: uniqueTeam2Batters,
            team2_bowlers: uniqueTeam2Bowlers,
            simulator: document.getElementById('simulator-type').value,
            n_simulations: nSimulations,
            venue_id: venueId,
            use_toss: useToss,
            gender: currentGender
        };
        
        try {
            // Use streaming endpoint for progress updates
            const response = await fetch('/api/simulate-stream', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                buffer += decoder.decode(value, { stream: true });
                
                // Process complete SSE messages
                const lines = buffer.split('\n');
                buffer = lines.pop(); // Keep incomplete line in buffer
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            
                            if (data.type === 'progress') {
                                // Update targets for smooth animation
                                targetCount = data.completed;
                                currentRate = data.rate;
                                // Animation loop will smoothly update the UI
                            }
                            else if (data.type === 'result') {
                                // Stop animation and show final results
                                simulationComplete = true;
                                clearInterval(animationInterval);
                                
                                // Ensure progress shows 100%
                                document.getElementById('progress-fill').style.width = '100%';
                                document.getElementById('progress-count').textContent = nSimulations.toLocaleString();
                                
                                // Small delay to show 100% before hiding
                                setTimeout(() => {
                                    document.getElementById('loading').style.display = 'none';
                                    displayResults(data, team1Name, team2Name);
                                }, 300);
                            }
                            else if (data.type === 'error') {
                                simulationComplete = true;
                                clearInterval(animationInterval);
                                document.getElementById('loading').style.display = 'none';
                                alert('Error: ' + data.error);
                            }
                        } catch (e) {
                            console.error('Error parsing SSE data:', e);
                        }
                    }
                }
            }
        } catch (error) {
            document.getElementById('loading').style.display = 'none';
            alert('Error running simulation: ' + error.message);
        }
    }
    
    function displayResults(data, team1Name, team2Name) {
        // Update results
        document.getElementById('result-team1-name').textContent = team1Name;
        document.getElementById('result-team2-name').textContent = team2Name;
        
        document.getElementById('result-team1-prob').textContent = data.team1_win_prob + '%';
        document.getElementById('result-team2-prob').textContent = data.team2_win_prob + '%';
        
        document.getElementById('result-team1-bar').style.width = data.team1_win_prob + '%';
        document.getElementById('result-team2-bar').style.width = data.team2_win_prob + '%';
        
        document.getElementById('result-team1-score').textContent = data.avg_team1_score;
        document.getElementById('result-team2-score').textContent = data.avg_team2_score;
        
        document.getElementById('result-team1-range').textContent = 
            `${data.team1_score_range[0]} - ${data.team1_score_range[1]}`;
        document.getElementById('result-team2-range').textContent = 
            `${data.team2_score_range[0]} - ${data.team2_score_range[1]}`;
        
        // Show toss info if available (now shows per-simulation statistics)
        const tossResult = document.getElementById('toss-result');
        if (data.toss_info) {
            const ti = data.toss_info;
            document.getElementById('toss-stats-text').textContent = 
                `Toss: Team 1 won ${ti.team1_won_toss_pct}% | Elected to field ${ti.chose_field_pct}% | Team 1 batted first ${ti.team1_batted_first_pct}%`;
            tossResult.style.display = 'block';
        } else {
            tossResult.style.display = 'none';
        }
        
        // Build meta string
        let meta = `${data.n_simulations.toLocaleString()} simulations using ${data.simulator === 'nn' ? 'Neural Network' : 'Fast Lookup'} engine in ${data.elapsed_ms.toFixed(0)}ms`;
        if (data.h2h_rate !== null && data.h2h_rate !== undefined) {
            meta += ` | H2H data used: ${data.h2h_rate}%`;
        }
        if (data.venue_id) {
            meta += ` | Venue #${data.venue_id}`;
        }
        document.getElementById('result-meta').textContent = meta;
        
        document.getElementById('results').style.display = 'block';
        
        // Display scorecard if available (NN simulator only)
        const scorecardSection = document.getElementById('scorecard-section');
        if (data.scorecard) {
            displayScorecard(data.scorecard, team1Name, team2Name);
            scorecardSection.style.display = 'block';
        } else {
            scorecardSection.style.display = 'none';
        }
    }
    
    function showInnings(inningsNum) {
        // Update tabs
        document.getElementById('tab-inn1').className = inningsNum === 1 ? 'btn btn-primary' : 'btn';
        document.getElementById('tab-inn2').className = inningsNum === 2 ? 'btn btn-primary' : 'btn';
        
        // Show/hide innings cards
        document.getElementById('innings1-card').style.display = inningsNum === 1 ? 'block' : 'none';
        document.getElementById('innings2-card').style.display = inningsNum === 2 ? 'block' : 'none';
    }
    
    function displayScorecard(scorecard, team1Name, team2Name) {
        // Helper to format overs
        const formatOvers = (overs) => {
            const fullOvers = Math.floor(overs);
            const balls = Math.round((overs % 1) * 10);
            return balls > 0 ? `${fullOvers}.${balls}` : `${fullOvers}`;
        };
        
        // Helper to format dismissal ESPN-style
        const formatDismissal = (b, bowlers) => {
            if (b.dismissal === 'not out') {
                return '<span style="color: var(--accent-green); font-weight: 500;">not out</span>';
            }
            // Find bowler name
            const bowlerName = bowlers.find(bl => bl.player_id === b.dismissed_by)?.name || 'Unknown';
            const shortBowlerName = bowlerName.split(' ').pop(); // Last name only
            return `<span style="color: var(--text-muted);">b ${shortBowlerName}</span>`;
        };
        
        // Result banner
        document.getElementById('scorecard-result-text').textContent = scorecard.result
            .replace('Team 1', team1Name)
            .replace('Team 2', team2Name);
        
        // ========== FIRST INNINGS ==========
        document.getElementById('innings1-team-name').textContent = team1Name + ' Innings';
        const overs1 = formatOvers(scorecard.team1_overs);
        document.getElementById('innings1-total').textContent = 
            `${scorecard.team1_total}/${scorecard.team1_wickets} (${overs1} Ov)`;
        
        // Calculate extras (estimate - total minus sum of individual runs)
        const battingRuns1 = scorecard.team1_batting.reduce((sum, b) => sum + b.runs, 0);
        const extras1 = Math.max(0, scorecard.team1_total - battingRuns1);
        document.getElementById('innings1-extras').textContent = `(b 0, lb 0, w ${extras1}, nb 0) ${extras1}`;
        document.getElementById('innings1-total-row').textContent = 
            `${scorecard.team1_total} (${scorecard.team1_wickets} wkts, ${overs1} Ov)`;
        
        // First innings batting
        const batting1 = document.getElementById('innings1-batting');
        batting1.innerHTML = '';
        scorecard.team1_batting.filter(b => b.balls > 0 || b.dismissal !== 'not out').forEach(b => {
            batting1.innerHTML += `
                <tr style="border-bottom: 1px solid var(--bg-tertiary);">
                    <td style="text-align: left; padding: 0.5rem;">
                        <div style="font-weight: 500;">${b.name || 'Player ' + b.player_id}</div>
                        <div style="font-size: 0.75rem;">${formatDismissal(b, scorecard.team2_bowling)}</div>
                    </td>
                    <td style="text-align: center; padding: 0.5rem; font-weight: 700;">${b.runs}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.balls}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.fours}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.sixes}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.strike_rate}</td>
                </tr>
            `;
        });
        
        // First innings bowling (Team 2's bowlers)
        const bowling1 = document.getElementById('innings1-bowling');
        bowling1.innerHTML = '';
        scorecard.team2_bowling.filter(b => b.balls > 0).forEach(b => {
            bowling1.innerHTML += `
                <tr style="border-bottom: 1px solid var(--bg-tertiary);">
                    <td style="text-align: left; padding: 0.5rem; font-weight: 500;">${b.name || 'Player ' + b.player_id}</td>
                    <td style="text-align: center; padding: 0.5rem;">${b.overs}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">0</td>
                    <td style="text-align: center; padding: 0.5rem;">${b.runs}</td>
                    <td style="text-align: center; padding: 0.5rem; font-weight: 700; color: ${b.wickets > 0 ? 'var(--accent-green)' : 'inherit'};">${b.wickets}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.economy}</td>
                </tr>
            `;
        });
        
        // ========== SECOND INNINGS ==========
        document.getElementById('innings2-team-name').textContent = team2Name + ' Innings';
        const overs2 = formatOvers(scorecard.team2_overs);
        document.getElementById('innings2-total').textContent = 
            `${scorecard.team2_total}/${scorecard.team2_wickets} (${overs2} Ov)`;
        document.getElementById('innings2-target').textContent = scorecard.target;
        
        // Calculate extras
        const battingRuns2 = scorecard.team2_batting.reduce((sum, b) => sum + b.runs, 0);
        const extras2 = Math.max(0, scorecard.team2_total - battingRuns2);
        document.getElementById('innings2-extras').textContent = `(b 0, lb 0, w ${extras2}, nb 0) ${extras2}`;
        document.getElementById('innings2-total-row').textContent = 
            `${scorecard.team2_total} (${scorecard.team2_wickets} wkts, ${overs2} Ov)`;
        
        // Second innings batting
        const batting2 = document.getElementById('innings2-batting');
        batting2.innerHTML = '';
        scorecard.team2_batting.filter(b => b.balls > 0 || b.dismissal !== 'not out').forEach(b => {
            batting2.innerHTML += `
                <tr style="border-bottom: 1px solid var(--bg-tertiary);">
                    <td style="text-align: left; padding: 0.5rem;">
                        <div style="font-weight: 500;">${b.name || 'Player ' + b.player_id}</div>
                        <div style="font-size: 0.75rem;">${formatDismissal(b, scorecard.team1_bowling)}</div>
                    </td>
                    <td style="text-align: center; padding: 0.5rem; font-weight: 700;">${b.runs}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.balls}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.fours}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.sixes}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.strike_rate}</td>
                </tr>
            `;
        });
        
        // Second innings bowling (Team 1's bowlers)
        const bowling2 = document.getElementById('innings2-bowling');
        bowling2.innerHTML = '';
        scorecard.team1_bowling.filter(b => b.balls > 0).forEach(b => {
            bowling2.innerHTML += `
                <tr style="border-bottom: 1px solid var(--bg-tertiary);">
                    <td style="text-align: left; padding: 0.5rem; font-weight: 500;">${b.name || 'Player ' + b.player_id}</td>
                    <td style="text-align: center; padding: 0.5rem;">${b.overs}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">0</td>
                    <td style="text-align: center; padding: 0.5rem;">${b.runs}</td>
                    <td style="text-align: center; padding: 0.5rem; font-weight: 700; color: ${b.wickets > 0 ? 'var(--accent-green)' : 'inherit'};">${b.wickets}</td>
                    <td style="text-align: center; padding: 0.5rem; color: var(--text-muted);">${b.economy}</td>
                </tr>
            `;
        });
        
        // Show first innings by default
        showInnings(1);
    }
</script>
{% endblock %}

